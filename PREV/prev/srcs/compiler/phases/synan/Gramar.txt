--- Gramar ---

# Start source

Source -> decl decl' .
decl' -> .
decl' -> decl decl' .

# Declaration

decl -> typ arg ; .
decl -> var arg ; .
decl -> fun identifier ( args ) : type P_expr ; .

# Arguments

args -> .
args -> arg args' .
args' -> .
args' -> , arg args' .

arg -> identifier : type .

# Proxy expresion

P_expr -> .
P_expr -> = expr .

# Type

type -> void .
type -> bool .
type -> char .
type -> int .
type -> arr[expr] type .
type -> rec ( args ) .
type -> ptr type .
type -> identifier .
type -> ( type ) .

# Unary operator

unop -> ! .
unop -> + .
unop -> - .
unop -> $ .
unop -> @ .

# Bynary operator

binop -> - .
binop -> + .
binop -> ior .
binop -> ^ .
binop -> & .
binop -> == .
binop -> != .
binop -> <= .
binop -> >= .
binop -> < .
binop -> > .
binop -> * .
binop -> / .
binop -> % .
binop -> = .
binop -> dot .
binop -> , .
binop -> : .
binop -> ; .
binop -> [ .
binop -> ] .
binop -> ( .
binop -> ) .
binop -> { .
binop -> } .


# Expresion
expr -> literal expr'' expr''' .
# expr -> unop expr .
# expr -> expr binop expr .

# Covers identifier ( exprs )
expr -> identifier expr' expr'' expr''' .
expr' -> .
expr' -> ( exprs ) .

exprs -> .
exprs -> expr exprs' .
exprs' -> .
exprs' -> , expr exprs' .

# Covers expr [ expr ]
expr'' -> [ expr ] expr'' .
expr'' -> .

# Covers expr.identifier
expr''' -> dot identifier expr''' .
expr''' -> .

expr -> new ( type ) .
expr -> del ( expr ) .

# Compound Expresion
expr -> { stmts : expr where_o } .

stmts -> stmt stmts' .
stmts' -> .
stmts' -> stmt stmts' .

where_o -> .
where_o -> where decl decl' .


# Covers (expr:type) and (expr)
expr -> ( expr expr'''' .
expr'''' -> : type ) .
expr'''' -> ) .
