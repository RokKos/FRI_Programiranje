{"version":3,"sources":["_dependencies/match-viewer/curves/curve.ts","_dependencies/match-viewer/curves/sections/section.ts","_dependencies/match-viewer/math/round.ts","_dependencies/match-viewer/curves/sections/step.ts","_dependencies/match-viewer/math/sineEquation.ts","_dependencies/match-viewer/math/circle.ts","_dependencies/match-viewer/attachable.ts","_dependencies/match-viewer/particleEffect.ts","_dependencies/match-viewer/assets.ts","_dependencies/match-viewer/textureAnimation.ts","_dependencies/match-viewer/curves/sections/boolean.ts","_dependencies/match-viewer/textureEntity.ts","_dependencies/match-viewer/util/color.ts","_dependencies/match-viewer/camera.ts","_dependencies/match-viewer/entity.ts","_dependencies/match-viewer/curves/sections/text.ts","_dependencies/match-viewer/textEntity.ts","_dependencies/match-viewer/gameDetails.ts","_dependencies/match-viewer/matchDetails.ts","_dependencies/match-viewer/chart.ts","_dependencies/match-viewer/curves/sections/linear.ts","_dependencies/match-viewer/curves/sections/sine.ts","_dependencies/match-viewer/attachSection.ts","_dependencies/match-viewer/particleEntity.ts","_dependencies/match-viewer/botDetails.ts","_dependencies/match-viewer/parsedReplay.ts","_dependencies/match-viewer/index.ts","_dependencies/components/MatchBasic.tsx","_dependencies/components/StatisticChart.tsx","_dependencies/components/BotDetailsView.tsx","_dependencies/components/MatchAdvanced.tsx","components/LocalMatchViewer.tsx","components/ReplayPicker.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Curve","sections","section","this","length","lastSection","endTime","Error","JSON","stringify","push","time","sectionIndex","getSectionIndex","endRangeValue","getValue","RangeError","leftIndex","rightIndex","middleIndex","Math","floor","middleSection","endTimes","forEach","findEndTime","curves","curve","isEmpty","curveEndTime","getEndTime","findStartTime","startTime","curveStartTime","getStartTime","throwErrorIfEmpty","curveName","Section","errorIfUndefined","values","i","undefined","round","value","numDecimals","factor","pow","NAME","StepSection","_time","prevSection","dict","entityId","attribute","name","SineEquation","t0","A","r","B","C","sin","toRadians","degrees","PI","normalizeAngleRad","angle","Attachable","x","y","rotation","visibility","scale","attach","getEntity","screenHeight","worldToScreen","getScale","baseEntity","attachToEntityId","attachRotation","attachedEntityAngle","atan2","getRotationDeg","xTmp","yTmp","cos","getXY","baseEntityX","baseEntityY","attachX","attachY","isVisible","attachVisibility","isBaseVisible","getVisibility","attachScale","attachAngle","getAngle","ParticleEffect","textures","settings","effectPath","images","image","loadTexture","Assets","path","loadedTextures","Map","loadedAnimations","loadedParticleEffects","texture","Texture","from","scaleMode","SCALE_MODES","LINEAR","baseTexture","mipmap","MIPMAP_MODES","OFF","loadAssets","replay","assets","callback","a","texturesToLoad","getUniqueTexturePaths","Array","isTextureAnimation","textureName","animationPath","fetch","request","json","data","set","TextureAnimation","parse","texturePath","particleEffectsToLoad","getUniqueParticleEffects","effectName","frames","loop","duration","frame","deltaTime","elapsed","AnimationFrame","includes","TextureEntityAttribute","BooleanSection","TextureEntity","id","sprite","Sprite","width","height","layer","opacity","attachable","_assets","t","add","onClick","interactive","buttonMode","on","delta","visible","getTexture","alpha","anchor","zIndex","getPreviousSectionEndTime","get","X","Y","WIDTH","HEIGHT","ROTATION_DEG","TEXTURE","LAYER","OPACITY","VISIBILITY","SCALE","ATTACH","getAttributes","colorToNumber","color","parseInt","substr","CameraAttribute","CAMERA_ID_PREFIX","CAMERA_DEFAULT_ID","CAMERA_HUD_ID","Camera","zoom","viewport","position","pivot","ZOOM","createCenteredCamera","camera","addSection","finishSetup","HUD_ID_PREFIX","TextSection","text","TextEntityAttribute","TEXT_ID_PREFIX","TextEntity","textDisplay","Text","numberText","numberTextDecimals","anchorX","anchorY","fontSize","fontFamily","fontStyle","fontWeight","e","toFixed","style","fill","TEXT","NUMBER_TEXT","NUMBER_TEXT_DEC","COLOR","ANCHOR_X","ANCHOR_Y","FONT_SIZE","FONT_FAMILY","FONT_STYLE","FONT_WEIGHT","GameDetails","gameNamePretty","gameName","gameVersion","assetsVersion","backgroundColor","showEntityPath","ShowEntityPathSettings","CameraSettings","pathColor","pathAlpha","clickedEntityTint","pathWidth","drawingTimeInterval","MatchDetail","description","Chart","series","LinearSection","sectionDuration","elapsedDuration","subsectionValue","SineSection","sine","_prevSection","AttachSection","Attach","ParticleEntityAttribute","PARTICLE_ID_PREFIX","ParticleEntity","container","Container","emitter","effectDuration","defaultScale","effect","emit","Emitter","emitterLifetime","updateEmitter","emitTime","emitEndTime","getCurrentSectionEndTime","previousTime","elapsedTime","cleanup","playOnce","update","updateDelta","abs","particleCount","EMIT","EFFECT","BotDetails","botName","teamIndex","rank","totalCpuTime","numberOfTimeouts","disqualified","disqualificationTime","disqualificationReason","SUPPORTED_SECTION_TYPES","STANDALONE_CURVE_ID_PREFIX","ParsedReplay","gameDetails","matchDetails","botDetails","teamsFinalOrder","charts","entities","cameras","standaloneCurves","paths","Set","entity","has","endTimeMax","cameraWidth","cameraHeight","sectionRaw","sectionType","type","isStandaloneCurve","curveId","startsWith","isCamera","isTextEntity","isParticleEntity","message","parseSections","chart","statistics","statistic","s","ref","curveRef","getCurve","linkChartsWithCurves","detail","teamsFinalOrderLength","console","warn","MatchViewerApplication","matchDuration","playbackSpeed","gameCameras","currentCamera","Application","startGame","replayRaw","assetsBaseUrl","app","renderer","view","gameViewport","sortableChildren","stage","addChild","hudViewport","camerasMap","sort","b","toUpperCase","localeCompare","toOrderedArrayOfCameras","defaultCamera","hudCamera","hudToScreen","assetPath","graphics","Graphics","clickedEntity","registerOnClickCallback","tint","clear","beginFill","size","drawCircle","endFill","registerOnEntityClickShowPath","prevTime","ticker","deltaScale","start","error","MatchBasic","gameCanvas","timeUpdateInterval","state","cameraIndex","isPlaying","insideSpeedSlider","speedSliderTabId","showCameras","isFull","overlayOpacity","forceViewerWidth","numberOfCameras","errorMessage","puiRef","createRef","componentDidMount","window","addEventListener","updateViewerWidth","loadReplayAndStart","componentWillUnmount","removeEventListener","destroy","setState","clearInterval","response","responseClone","rawData","props","replayUrl","clone","replayFile","arrayBuffer","Pako","Uint8Array","to","Object","JSZip","files","replayFileZip","async","appendChild","onCameraChange","setInterval","setTime","setApplication","containerWidth","availableW","screen","availableH","current","clientHeight","availableRatio","viewerRatio","loopMatch","onChangeTime","event","target","onTogglePlay","setTimeout","onResetSpeed","onSpeedChange","camIndex","goFull","goFullScreen","component","enabled","onChange","className","thisDiv","Glyphicon","glyph","min","max","step","change","tooltip","onMouseEnter","onMouseLeave","tabIndex","onBlur","map","key","Component","StatisticChart","stat","itemStyle","lineStyle","showSymbol","minWidth","option","trigger","legend","grid","left","right","bottom","top","containLabel","xAxis","axisLabel","showMaxLabel","formatter","yAxis","BotDetailsView","botIndex","details","Col","md","Row","marginTop","MatchAdvanced","getBotsVersus","d1","d2","indexOf","padding","LocalMatchViewer","goBack","home","history","location","URLSearchParams","search","assetsUrl","assetsServerPort","Grid","Button","ReplayPicker","directoryItems","currentPath","chosenReplayPath","navigate","item","endsWith","url","el","document","createElement","innerHTML","list","getElementsByTagName","list2","innerText","back","newPath","lastIndexOf","Image","src","App","process","REACT_APP_ASSETS_SERVER_PORT","exact","Boolean","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f09cb47c.chunk.js","sourcesContent":["import {Section} from \"./sections/section\";\n\n/**\n * A curve built out of sections. You need to specify of which type all the sections must be.\n */\nexport class Curve<T = never> {\n    sections: Section<T>[] = [];\n\n    add(section: Section<T>) {\n        if (this.sections.length > 0) {\n\n            let lastSection = this.sections[this.sections.length - 1];\n\n            if (lastSection.endTime > section.endTime) {\n                throw new Error(`Section time must be > than previous section time in this curve. `\n                + `\\nSection: ${JSON.stringify(section)} \\nPrevious section: ${JSON.stringify(lastSection)}`);\n            }\n        }\n\n        this.sections.push(section);\n    }\n\n    /**\n     * Returns value represented in the curve at specified time.\n     * Note that the first sections can only be queried by it's endTime as it\n     * has no previous Section and thus can't calculate the intermediate values.\n     *\n     * @param {number} time\n     * @returns {T} - a value in the curve represented by specified time\n     */\n    getValue(time: number): T {\n        let sectionIndex = this.getSectionIndex(time);\n        let section = this.sections[sectionIndex];\n\n        // If first we don't do interpolation\n        if (sectionIndex === 0) {\n            return section.endRangeValue;\n        }\n        // This only happens when section is last\n        if (section.endTime <= time) {\n            return section.endRangeValue;\n        }\n\n        return section.getValue(time, this.sections[sectionIndex - 1]);\n    }\n\n    getPreviousSectionEndTime(time: number): number {\n        let sectionIndex = this.getSectionIndex(time);\n        let section = this.sections[sectionIndex];\n\n        if (sectionIndex === 0) {\n            return section.endTime;\n        }\n        if (section.endTime <= time) {\n            return section.endTime;\n        }\n        return this.sections[sectionIndex - 1].endTime;\n    }\n\n    /**\n     * Returns current section time or null if the time is larger\n     * than the last section end time\n     */\n    getCurrentSectionEndTime(time: number): number | null {\n        let sectionIndex = this.getSectionIndex(time);\n        let section = this.sections[sectionIndex];\n        if (section.endTime < time) return null;\n        return section.endTime;\n    }\n\n    getSectionIndex(time: number): number {\n        if (this.sections.length === 0) {\n            throw new RangeError(`Curve is empty.`);\n        }\n        // Time to small\n        if (this.sections[0].endTime > time) {\n            throw new RangeError(`Current time ${time} is smaller than the end time of the first section` +\n                ` ${this.sections[0].endTime}.`)\n        }\n        // Time to large\n        let lastSection = this.sections[this.sections.length - 1];\n        if (lastSection.endTime <= time) {\n            return this.sections.length - 1;\n        }\n        // First section\n        let firstSection = this.sections[0];\n        if (firstSection.endTime === time) {\n            return 0;\n        }\n\n        let leftIndex = 0;\n        let rightIndex = this.sections.length - 1;\n\n        // Bisection (binary search)\n        while (rightIndex - leftIndex > 1) {\n            let middleIndex = Math.floor(leftIndex + (rightIndex - leftIndex) / 2);\n\n            let middleSection = this.sections[middleIndex];\n\n            if (middleSection.endTime === time) return middleIndex;\n            else if (middleSection.endTime < time) leftIndex = middleIndex;\n            else rightIndex = middleIndex;\n        }\n\n        let correctIndex = (time <= this.sections[leftIndex].endTime) ? leftIndex : rightIndex;\n        return correctIndex;\n    }\n\n    /** Returns the time when the curve starts. */\n    getStartTime(): number {\n        if (this.sections.length === 0) throw new Error(`Curve is empty.`);\n        else return this.sections[0].endTime;\n    }\n\n    /** Returns the end time of the last sections in the curve. */\n    getEndTime(): number {\n        if (this.sections.length === 0) throw new Error(`Curve is empty.`);\n        else return this.sections[this.sections.length - 1].endTime;\n    }\n\n    /** Returns end times of all sections in the curve. */\n    getSectionsEndTimes(): number[] {\n        let endTimes: number[] = [];\n        this.sections.forEach(section => endTimes.push(section.endTime));\n        return endTimes;\n    }\n\n    numberOfSections(): number {\n        return this.sections.length;\n    }\n\n    isEmpty(): boolean {\n        return this.sections.length === 0;\n    }\n}\n\nexport function findEndTime(curves: Curve<any>[]): number {\n    let endTime = 0;\n    curves.forEach(curve => {\n        if (!curve.isEmpty()) {\n            let curveEndTime = curve.getEndTime();\n            if (curveEndTime > endTime) endTime = curveEndTime;\n        }\n    });\n    return endTime;\n}\n\nexport function findStartTime(curves: Curve<any>[]): number {\n    let startTime = -1;\n    curves.forEach(curve => {\n        if (!curve.isEmpty()) {\n            let curveStartTime = curve.getStartTime();\n            if (curveStartTime < startTime || startTime === -1) startTime = curveStartTime;\n        }\n    });\n    return startTime;\n}\n\nexport function throwErrorIfEmpty(curve: Curve<any>, curveName: string) {\n    if (curve.isEmpty()) {\n        throw new Error(`Curve ${curveName} should not be empty.`);\n    }\n}","/**\n * Abstract class that different Sections need to implement\n * in order to be used in curves.\n */\nexport abstract class Section<T> {\n\n    // Cannot use YourClassName.name due to minification problems in build\n    // Override it in a class that extends this\n    static NAME: string;\n\n    // The time at the end of the sections.\n    endTime: number;\n\n    // Holds the last value in the sections, that the next sections\n    // in the curve will use to calculate intermediate values.\n    endRangeValue: T;\n\n    constructor(endTime: number, endRangeValue: T) {\n        this.endTime = endTime;\n        this.endRangeValue = endRangeValue;\n    }\n\n    // Return a value within this sections based on custom logic.\n    abstract getValue(time: number, prevSection: Section<any>): T;\n}\n\nexport function errorIfUndefined(values: any[]) {\n    for (let i = 0; i < values.length; i++) {\n        let value = values[i];\n\n        if (value === undefined) {\n            throw new Error(`Value with index ${i} is undefined.`);\n        }\n    }\n}","export function round(value: number, numDecimals: number): number {\n    let factor = Math.pow(10, numDecimals);\n    return Math.round(value * factor) / factor;\n}","import {errorIfUndefined, Section} from \"./section\";\nimport {round} from \"../../math/round\";\n\n/**\n * A sections representing a simple step function,\n * where the value in one sections is always the same.\n */\nexport class StepSection extends Section<number> {\n\n    static readonly NAME: string = \"StepSection\";\n\n    getValue(_time: number, prevSection: Section<number>): number {\n        return prevSection.endRangeValue;\n    }\n\n    static parse(dict: any): StepSection {\n        errorIfUndefined([dict.endTime, dict.endRangeValue]);\n        return new StepSection(dict.endTime, dict.endRangeValue);\n    }\n\n    static toDict(entityId: string, attribute: string, endTime: number, endRangeValue: number): object {\n        return {\n            \"type\": StepSection.name,\n            \"entityId\": entityId,\n            \"attribute\": attribute,\n            \"endTime\": round(endTime, 3),\n            \"endRangeValue\": round(endRangeValue, 3)\n        };\n    }\n}\n","/**\n * A partial sine equation curveRef structure in format A + r * sin(B * (t - t0) + C).\n *\n * A - offsets in y axis\n * r - radius of the function\n * B - frequency of the sine\n * t0 - time when the equation started\n * C - offset in x axis\n */\nexport class SineEquation {\n    t0: number;\n    A: number;\n    r: number;\n    B: number;\n    C: number;\n\n    constructor(t0: number, A: number, r: number, B: number, C: number) {\n        this.t0 = t0;\n        this.A = A;\n        this.r = r;\n        this.B = B;\n        this.C = C;\n    }\n\n    // Returns a value on sine function.\n    //\n    // time - time based on the start of the function (time at start\n    //        of the function is 0)\n    getValue(time: number): number {\n        return this.A + this.r * Math.sin(this.B * (time - this.t0) + this.C);\n    }\n}\n\n\n","import {SineEquation} from \"./sineEquation\";\n\nexport function getCircularMovementParametricEquations(time: number, velocity: number, rotationVelocity: number,\n                                                       angle: number, x: number, y: number): [SineEquation, SineEquation] {\n    angle = normalizeAngleDeg(angle);\n    let rotationVelocityRad = toRadians(rotationVelocity);\n\n    // Radius of the circle\n    let r = getCircleRadius(velocity, rotationVelocity);\n\n    // Center points of the circle\n    let [centerX, centerY] = getCircleCenter(velocity, rotationVelocity, angle, x, y);\n\n    // Time that the object needs to finish one full lap\n    let T = (2 * Math.PI) / Math.abs(rotationVelocityRad);\n\n    // Offsets where the object begins the movement\n    let timeOffset = Math.atan((y - centerY) / (x - centerX)) / rotationVelocityRad;\n    if ((rotationVelocityRad < 0 && angle > 0 && angle < 180) ||\n        (rotationVelocityRad >= 0 && angle > 180 && angle < 360)) {\n        timeOffset += T / 2;\n    }\n    let offsetX = rotationVelocityRad * timeOffset + Math.PI / 2;\n    let offsetY = rotationVelocityRad * timeOffset;\n\n    // Build sine equations for both coordinates\n    let sineX = new SineEquation(time, centerX, r, rotationVelocityRad, offsetX);\n    let sineY = new SineEquation(time, centerY, r, rotationVelocityRad, offsetY);\n\n    return [sineX, sineY];\n}\n\nexport function getCircleCenter(velocity: number, rotationVelocityDeg: number,\n                                angle: number, x: number, y: number): [number, number] {\n\n    angle = normalizeAngleDeg(angle);\n    let r = getCircleRadius(velocity, rotationVelocityDeg);\n\n    // Parametrize velocity\n    let velocityVectorX = velocity * Math.cos(toRadians(angle));\n    let velocityVectorY = velocity * Math.sin(toRadians(angle));\n\n    // Make a unit vector from velocity vector\n    let velocityUnitVectorX = velocityVectorX / velocity;\n    let velocityUnitVectorY = velocityVectorY / velocity;\n\n    let invert = (rotationVelocityDeg < 0) ? 1 : -1;\n\n    // Rotate the velocity unit vector towards the center of the circle\n    let eX = velocityUnitVectorY * invert;\n    let eY = -velocityUnitVectorX * invert;\n\n    // Calculate the center of the circle\n    let centerX = x + r * eX;\n    let centerY = y + r * eY;\n\n    return [centerX, centerY];\n}\n\nexport function getCircleRadius(velocity: number, rotationVelocity: number) {\n    return velocity / Math.abs(toRadians(rotationVelocity));\n}\n\nexport function toRadians(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\nexport function normalizeAngleDeg(angle: number): number {\n    angle %= 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\nexport function normalizeAngleRad(angle: number): number {\n    angle %= (Math.PI * 2);\n    if (angle < 0) angle += Math.PI * 2;\n    return angle;\n}","import {Curve} from \"./curves/curve\";\nimport {Attach} from \"./attachSection\";\nimport {normalizeAngleRad, toRadians} from \"./math/circle\";\n\n/**\n * Given that an instance of this class holds curves\n * of an entity that is attached to another entity it\n * can calculate specified attributes of an entity based\n * on the attributes of the entity it is attached to.\n */\nexport class Attachable {\n\n    x: Curve<number>;\n    y: Curve<number>;\n    rotation: Curve<number>;\n    visibility: Curve<boolean>;\n    scale: Curve<number>;\n    // Defines to which other entity and how this\n    // entity is attached (if to any).\n    attach: Curve<Attach>;\n    // Creator of this entity instance can define\n    // how this instance can access other entities\n    // in the replay using their id\n    getEntity: (id: string) => (Attachable | undefined);\n\n    constructor(x: Curve<number>,\n                y: Curve<number>,\n                rotation: Curve<number>,\n                visibility: Curve<boolean>,\n                scale: Curve<number>,\n                attach: Curve<Attach>,\n                getEntity: (id: string) => (Attachable | undefined)) {\n        this.x = x;\n        this.y = y;\n        this.rotation = rotation;\n        this.visibility = visibility;\n        this.scale = scale;\n        this.attach = attach;\n        this.getEntity = getEntity;\n    }\n\n    // Returns [x,y] taking into account the base entity it is attached to.\n    getXY(time: number, screenHeight: number, worldToScreen: number): [number, number] {\n        // Get a scale as inherited from the entity it is attached to but\n        // ignoring its own scale (we don't want it to affects its position.\n        let scale = this.getScale(time) / this.scale.getValue(time);\n\n        let x = this.x.getValue(time) * worldToScreen * scale;\n        let y = screenHeight - this.y.getValue(time) * worldToScreen * scale;\n\n        // If x and/or y coordinate is attached to other entity, add\n        // its x and/or y coordinate to this entity.\n        // If attachRotation is set to true then also modify x and/or y\n        // coordinate to rotate around the entity it is attached to.\n        if (!this.attach.isEmpty()) {\n            let attach = this.attach.getValue(time);\n            let baseEntity = this.getEntity(attach.attachToEntityId)!;\n\n            if (attach.attachRotation) {\n                // First calculate x and y positions in a local\n                // coordinate system of this entity disregarding\n                // where baseEntity is.\n                x = this.x.getValue(time) * scale;\n                y = this.y.getValue(time) * scale;\n\n                // Subtract 90 degrees to attached entity angle so that\n                // the x axis of local coordinate system faces the same\n                // way the base entity is facing.\n                let attachedEntityAngle = normalizeAngleRad(Math.atan2(x, y) - toRadians(90));\n\n                let baseEntityAngle = normalizeAngleRad(toRadians(baseEntity.getRotationDeg(time)));\n                let angle = baseEntityAngle - attachedEntityAngle;\n\n                // Turn x and y around based on the angle\n                let xTmp = x;\n                let yTmp = y;\n                x = xTmp * Math.cos(angle) - yTmp * Math.sin(angle);\n                y = yTmp * Math.cos(angle) + xTmp * Math.sin(angle);\n\n                // Convert world coordinates to screen coordinates\n                x *= worldToScreen;\n                y = screenHeight - y * worldToScreen;\n            }\n\n            let [baseEntityX, baseEntityY] = baseEntity.getXY(time, screenHeight, worldToScreen);\n\n            if (attach.attachX) {\n                x += baseEntityX\n            }\n            if (attach.attachY) {\n                y += baseEntityY - screenHeight;\n            }\n        }\n\n        return [x, y];\n    }\n\n    // Returns true if the entity is visible taking into account its\n    // base entity if attachVisibility is set to true. If base entity\n    // is not visible, then this entity is also not visible.\n    getVisibility(time: number): boolean {\n        let isVisible = this.visibility.getValue(time);\n\n        if (!this.attach.isEmpty()) {\n            let attach = this.attach.getValue(time);\n\n            if (attach.attachVisibility) {\n                let entityToAttachTo = this.getEntity(attach.attachToEntityId)!;\n                let isBaseVisible = entityToAttachTo.getVisibility(time);\n                return isVisible && isBaseVisible;\n            }\n        }\n\n        return isVisible;\n    }\n\n    // Get a scale of this object taking into account the scale\n    // of the entity it is attached to if attachScale is true.\n    getScale(time: number): number {\n        let scale = this.scale.getValue(time);\n\n        if (!this.attach.isEmpty()) {\n            let attach = this.attach.getValue(time);\n\n            if (attach.attachScale) {\n                let entityToAttachTo = this.getEntity(attach.attachToEntityId)!;\n                let baseScale = entityToAttachTo.getScale(time);\n                scale *= baseScale;\n            }\n        }\n\n        return scale;\n    }\n\n    // Get the angle of this entity taking into account all consecutive entities\n    // it is attached to (it is attached to one, that is attached to another one etc.)\n    // that have attachAngle field set to true.\n    getAngle(time: number): number {\n        let rotation = this.rotation.getValue(time);\n\n        // If the attachAngle is allowed then this entity\n        // will change its angle together with the entity it\n        // is attached to\n        if (!this.attach.isEmpty()) {\n            let attach = this.attach.getValue(time);\n\n            if (attach.attachAngle) {\n                let entityToAttachTo = this.getEntity(attach.attachToEntityId)!;\n                let baseRotation = entityToAttachTo.getAngle(time);\n                rotation += baseRotation;\n            }\n        }\n\n        return rotation\n    }\n\n    // Get the angle of this entity taking into account all consecutive entities\n    // it is attached to (it is attached to one, that is attached to another one etc.)\n    // that have attachRotation field set to true.\n    getRotationDeg(time: number): number {\n        let rotation = this.rotation.getValue(time);\n\n        if (!this.attach.isEmpty()) {\n            let attach = this.attach.getValue(time);\n\n            if (attach.attachRotation) {\n                let entityToAttachTo = this.getEntity(attach.attachToEntityId)!;\n                let baseRotation = entityToAttachTo.getRotationDeg(time);\n                rotation += baseRotation;\n            }\n        }\n\n        return rotation\n    }\n}","import {Texture} from \"pixi.js\";\nimport {errorIfUndefined} from \"./curves/sections/section\";\nimport {loadTexture} from \"./assets\";\nimport {EmitterConfig} from \"pixi-particles\";\n\nexport class ParticleEffect {\n    textures: Texture[];\n    scale: number;\n    settings: EmitterConfig;\n\n    constructor(textures: PIXI.Texture[], scale: number, settings: EmitterConfig) {\n        this.textures = textures;\n        this.scale = scale;\n        this.settings = settings;\n    }\n\n    static parse(dict: any, effectPath: string): ParticleEffect {\n        errorIfUndefined([dict.images, dict.scale, dict.settings]);\n\n        let textures: Texture[] = [];\n        dict.images.forEach(image => {\n            textures.push(loadTexture(`${effectPath}/${image}`))\n        });\n\n        return new ParticleEffect(textures, dict.scale, dict.settings);\n    }\n}","import {MIPMAP_MODES, SCALE_MODES, Texture} from \"pixi.js\";\nimport {isTextureAnimation, TextureAnimation} from \"./textureAnimation\";\nimport {ParticleEffect} from \"./particleEffect\";\nimport {ParsedReplay} from \"./parsedReplay\";\n\nexport class Assets {\n    path: string;\n    loadedTextures = new Map<string, Texture>();\n    loadedAnimations = new Map<string, TextureAnimation>();\n    loadedParticleEffects = new Map<string, ParticleEffect>();\n\n    constructor(path: string) {\n        this.path = path;\n    }\n}\n\nexport function loadTexture(path: string): Texture {\n    let texture = Texture.from(path, {scaleMode: SCALE_MODES.LINEAR});\n    // Turning off mipmap helps to reduce flickering of textures\n    texture.baseTexture.mipmap = MIPMAP_MODES.OFF;\n    return texture;\n}\n\nexport let loadAssets = async (replay: ParsedReplay,\n                               assets: Assets,\n                               callback: () => void) => {\n\n    let texturesToLoad = replay.getUniqueTexturePaths();\n\n    // Load textures & animations\n    for (let textureName of Array.from(texturesToLoad.values())) {\n        // Load animation\n        if (isTextureAnimation(textureName)) {\n            let animationPath = `${assets.path}/animations/${textureName}`;\n            let request = await fetch(`${animationPath}/anim.json`);\n            let data = await request.json();\n            assets.loadedAnimations.set(textureName, TextureAnimation.parse(data, animationPath));\n        }\n        // Load texture\n        else {\n            let texturePath = `${assets.path}/images/${textureName}`;\n            let texture = loadTexture(texturePath);\n            assets.loadedTextures.set(textureName, texture);\n        }\n    }\n\n    let particleEffectsToLoad = replay.getUniqueParticleEffects();\n\n    // Load particle effects\n    for (let effectName of Array.from(particleEffectsToLoad.values())) {\n        let effectPath = `${assets.path}/particles`;\n        let r = await fetch(`${effectPath}/${effectName}.json`);\n        let data = await r.json();\n        assets.loadedParticleEffects.set(effectName, ParticleEffect.parse(data, effectPath));\n    }\n\n    callback();\n};\n","import {errorIfUndefined} from \"./curves/sections/section\";\nimport {Texture} from \"pixi.js\";\nimport {loadTexture} from \"./assets\";\n\nexport class TextureAnimation {\n    frames: AnimationFrame[];\n    loop: boolean;\n    duration: number;\n\n    constructor(frames: AnimationFrame[], loop: boolean) {\n        this.frames = frames;\n        this.loop = loop;\n\n        this.duration = 0;\n        this.frames.forEach((frame: AnimationFrame) => {\n            this.duration += frame.duration;\n        });\n    }\n\n    getTexture(deltaTime: number): Texture {\n        // When animation that does not loop ends, use last frame\n        if (!this.loop && deltaTime > this.duration) {\n            return this.frames[this.frames.length - 1].texture;\n        }\n\n        // Find intermediate frame\n        deltaTime = deltaTime % this.duration;\n        let elapsed = 0;\n        let texture = this.frames[0].texture;\n\n        this.frames.forEach((frame: AnimationFrame) => {\n            if (elapsed <= deltaTime) {\n                texture = frame.texture;\n            } else {\n                return texture;\n            }\n            elapsed += frame.duration;\n        });\n        return texture;\n    }\n\n    static parse(dict: any, animationPath: string): TextureAnimation {\n        errorIfUndefined([dict.frames, dict.loop]);\n\n        let frames: AnimationFrame[] = [];\n        dict.frames.forEach(frame => {\n            frames.push(AnimationFrame.parse(frame, animationPath))\n        });\n\n        return new TextureAnimation(frames, dict.loop);\n    }\n}\n\nexport class AnimationFrame {\n    path: string;\n    texture: Texture;\n    duration: number;\n\n    constructor(path: string, duration: number, animationPath: string) {\n        this.path = path;\n        this.duration = duration;\n        this.texture = loadTexture(`${animationPath}/${path}`);\n    }\n\n    static parse(dict: any, animationPath: string): AnimationFrame {\n        errorIfUndefined([dict.path, dict.duration]);\n        return new AnimationFrame(dict.path, dict.duration, animationPath);\n    }\n}\n\nexport function isTextureAnimation(path: string): boolean {\n    return !path.includes(\".\");\n}","import {errorIfUndefined, Section} from \"./section\";\nimport {round} from \"../../math/round\";\n\n/**\n * A sections representing a boolean function.\n */\nexport class BooleanSection extends Section<boolean> {\n\n    static readonly NAME: string = \"BooleanSection\";\n\n    getValue(_time: number, prevSection: Section<boolean>): boolean {\n        return prevSection.endRangeValue;\n    }\n\n    static parse(dict: any): BooleanSection {\n        errorIfUndefined([dict.endTime, dict.endRangeValue]);\n        return new BooleanSection(dict.endTime, dict.endRangeValue);\n    }\n\n    static toDict(entityId: string, attribute: string, endTime: number, endRangeValue: boolean): object {\n        return {\n            \"type\": BooleanSection.name,\n            \"entityId\": entityId,\n            \"attribute\": attribute,\n            \"endTime\": round(endTime, 3),\n            \"endRangeValue\": endRangeValue\n        };\n    }\n}\n","import {Curve, findEndTime, findStartTime, throwErrorIfEmpty} from \"./curves/curve\";\nimport {Sprite, Texture, Graphics} from \"pixi.js\";\nimport {StepSection} from \"./curves/sections/step\";\nimport {Section} from \"./curves/sections/section\";\nimport {Attach} from \"./attachSection\";\nimport {Attachable} from \"./attachable\";\nimport {Entity} from \"./entity\";\nimport {ShowEntityPathSettings} from \"./gameDetails\";\nimport {isTextureAnimation, TextureAnimation} from \"./textureAnimation\";\nimport {BooleanSection} from \"./curves/sections/boolean\";\nimport {Assets} from \"./assets\";\n\nexport enum TextureEntityAttribute {\n    X,\n    Y,\n    WIDTH,\n    HEIGHT,\n    ROTATION_DEG,\n    LAYER,\n    TEXTURE,\n    OPACITY,\n    VISIBILITY,\n    SCALE,\n    ATTACH\n}\n\nexport function stringify(a: TextureEntityAttribute): string {\n    return TextureEntityAttribute[a]\n}\n\nexport class TextureEntity implements Entity {\n    id: string;\n\n    sprite = new Sprite();\n\n    x = new Curve<number>();\n    y = new Curve<number>();\n    rotation = new Curve<number>();\n    visibility = new Curve<boolean>();\n    scale = new Curve<number>();\n    // Defines to which other entity and how this\n    // entity is attached (if to any).\n    attach = new Curve<Attach>();\n    width = new Curve<number>();\n    height = new Curve<number>();\n    layer = new Curve<number>();\n    texture = new Curve<string>();\n    opacity = new Curve<number>();\n\n    // If this entity is attached to another entity\n    // it can calculate the attributes of this entity\n    // based on the entity it is attached to.\n    attachable: Attachable;\n\n    startTime: number = 0;\n\n    constructor(id: string, getEntity: (id: string) => (Attachable | undefined)) {\n        this.id = id;\n        this.attachable = new Attachable(this.x, this.y, this.rotation,\n            this.visibility, this.scale, this.attach, getEntity);\n    }\n\n    /**\n     * Call after all curves are set. This will setup all necessary\n     * things such as initialize empty curves to default values.\n     *\n     * if the mandatory curves don't have at least one Section,\n     * this method will throw an error. */\n    finishSetup(_assets: Assets) {\n        // Some curves should not be empty when initialized.\n        throwErrorIfEmpty(this.x, 'x');\n        throwErrorIfEmpty(this.y, 'y');\n        throwErrorIfEmpty(this.width, 'width');\n        throwErrorIfEmpty(this.texture, 'texture');\n\n        this.startTime = this.getStartTime();\n        let t = this.startTime;\n\n        // Set default values for empty curves.\n        if (this.height.isEmpty()) {\n            // Set height to match the width.\n            this.height.add(new StepSection(t, this.width.getValue(this.width.getStartTime())));\n        }\n        if (this.attachable.rotation.isEmpty()) {\n            this.attachable.rotation.add(new StepSection(t, 0));\n        }\n        if (this.layer.isEmpty()) {\n            this.layer.add(new StepSection(t, 1));\n        }\n        if (this.opacity.isEmpty()) {\n            this.opacity.add(new StepSection(t, 1));\n        }\n        if (this.attachable.visibility.isEmpty()) {\n            this.attachable.visibility.add(new BooleanSection(t, true));\n        }\n        if (this.attachable.scale.isEmpty()) {\n            this.attachable.scale.add(new StepSection(t, 1));\n        }\n        if (this.attachable.attach.isEmpty()) {\n            // Leave empty, it means this entity is not attached to any other entity\n        }\n    }\n\n    registerOnClickCallback(onClick: (entity: TextureEntity) => void) {\n        this.sprite.interactive = true;\n        this.sprite.buttonMode = true;\n\n        this.sprite.on('mousedown', () => {\n            onClick(this)\n        });\n        this.sprite.on('touchstart', () => {\n            onClick(this)\n        });\n    }\n\n    update(time: number, delta: number, assets: Assets, screenHeight: number, worldToScreen: number) {\n        if (time < this.startTime) {\n            this.sprite.visible = false;\n            return;\n        }\n\n        this.sprite.visible = this.attachable.getVisibility(time);\n        if (!this.sprite.visible) {\n            return;\n        }\n\n        this.sprite.texture = this.getTexture(time, assets.loadedTextures, assets.loadedAnimations);\n        [this.sprite.x, this.sprite.y] = this.attachable.getXY(time, screenHeight, worldToScreen);\n        this.sprite.width = this.width.getValue(time) * worldToScreen;\n        this.sprite.height = this.height.getValue(time) * worldToScreen;\n        this.sprite.angle = -this.attachable.getAngle(time);\n        this.sprite.alpha = this.opacity.getValue(time);\n        this.sprite.anchor.set(0.5, 0.5);\n        this.sprite.zIndex = this.layer.getValue(time);\n\n        let scale = this.attachable.getScale(time);\n        this.sprite.scale.x = (this.sprite.width / this.sprite.texture.width) * scale;\n        this.sprite.scale.y = (this.sprite.height / this.sprite.texture.height) * scale;\n    }\n\n    getTexture(time: number,\n               loadedTextures: Map<string, Texture>,\n               loadedAnimations: Map<string, TextureAnimation>): Texture {\n\n        let textureName = this.texture.getValue(time);\n        let prevSectionEndTime = this.texture.getPreviousSectionEndTime(time);\n        let deltaTime = time - prevSectionEndTime;\n\n        if (isTextureAnimation(textureName)) {\n            return loadedAnimations.get(textureName)!.getTexture(deltaTime);\n        } else {\n            return loadedTextures.get(textureName)!;\n        }\n    }\n\n    addSection(attribute: string, section: Section<any>) {\n        switch (attribute) {\n            case stringify(TextureEntityAttribute.X):\n                this.x.add(section);\n                return;\n            case stringify(TextureEntityAttribute.Y):\n                this.y.add(section);\n                return;\n            case stringify(TextureEntityAttribute.WIDTH):\n                this.width.add(section);\n                return;\n            case stringify(TextureEntityAttribute.HEIGHT):\n                this.height.add(section);\n                return;\n            case stringify(TextureEntityAttribute.ROTATION_DEG):\n                this.attachable.rotation.add(section);\n                return;\n            case stringify(TextureEntityAttribute.TEXTURE):\n                this.texture.add(section);\n                return;\n            case stringify(TextureEntityAttribute.LAYER):\n                this.layer.add(section);\n                return;\n            case stringify(TextureEntityAttribute.OPACITY):\n                this.opacity.add(section);\n                return;\n            case stringify(TextureEntityAttribute.VISIBILITY):\n                this.attachable.visibility.add(section);\n                return;\n            case stringify(TextureEntityAttribute.SCALE):\n                this.attachable.scale.add(section);\n                return;\n            case stringify(TextureEntityAttribute.ATTACH):\n                this.attachable.attach.add(section);\n                return;\n        }\n    }\n\n    getCurve(attribute: string): Curve<any> {\n        switch (attribute) {\n            case stringify(TextureEntityAttribute.X):\n                return this.x;\n            case stringify(TextureEntityAttribute.Y):\n                return this.y;\n            case stringify(TextureEntityAttribute.WIDTH):\n                return this.width;\n            case stringify(TextureEntityAttribute.HEIGHT):\n                return this.height;\n            case stringify(TextureEntityAttribute.ROTATION_DEG):\n                return this.rotation;\n            case stringify(TextureEntityAttribute.TEXTURE):\n                return this.texture;\n            case stringify(TextureEntityAttribute.LAYER):\n                return this.layer;\n            case stringify(TextureEntityAttribute.OPACITY):\n                return this.opacity;\n            case stringify(TextureEntityAttribute.VISIBILITY):\n                return this.visibility;\n            case stringify(TextureEntityAttribute.SCALE):\n                return this.scale;\n            case stringify(TextureEntityAttribute.ATTACH):\n                return this.attach;\n            default:\n                throw Error(`attribute ${attribute} is not valid`)\n        }\n    }\n\n    private getAttributes(): Curve<any>[] {\n        return [this.attachable.x, this.attachable.y, this.width, this.height, this.attachable.rotation,\n            this.texture, this.layer, this.opacity, this.attachable.visibility, this.attachable.scale,\n            this.attachable.attach];\n    }\n\n    getEndTime(): number {\n        return findEndTime(this.getAttributes());\n    }\n\n    getStartTime(): number {\n        return findStartTime(this.getAttributes());\n    }\n}\n\nexport function registerOnEntityClickShowPath(settings: ShowEntityPathSettings,\n                                              entities: Map<string, Entity>,\n                                              graphics: Graphics,\n                                              screenHeight: number,\n                                              worldToScreen: number) {\n    let clickedEntity: TextureEntity | null;\n\n    // Register onClick callback on all TextureEntities that can draw entity path\n    entities.forEach((entity: Entity) => {\n        if (entity instanceof TextureEntity) {\n\n            entity.registerOnClickCallback((entity: TextureEntity) => {\n                if (clickedEntity != null) {\n                    // Remove the path and tint\n                    clickedEntity.sprite.tint = 0xFFFFFF;\n                    graphics.clear();\n                    if (clickedEntity!.id === entity.id) {\n                        clickedEntity = null;\n                        return;\n                    }\n                }\n                clickedEntity = entity;\n\n                // Tint newly clicked entity\n                clickedEntity.sprite.tint = settings.clickedEntityTint;\n\n                // Draw entity path\n                graphics.clear();\n                graphics.beginFill(settings.pathColor);\n                graphics.alpha = settings.pathAlpha;\n\n                let startTime = clickedEntity.getStartTime();\n                let endTime = clickedEntity.getEndTime();\n\n                for (let t = startTime; t < endTime; t += settings.drawingTimeInterval) {\n                    let [x, y] = clickedEntity.attachable.getXY(t, screenHeight, worldToScreen);\n                    let size = settings.pathWidth * worldToScreen;\n                    graphics.drawCircle(x, y, size);\n                }\n                graphics.endFill();\n            });\n        }\n    });\n}\n\n","export function colorToNumber(color: string): number {\n    return parseInt(color.substr(1, color.length), 16);\n}\n\nexport function colorToString(color: number): string {\n    return \"#\" + color.toString(16).toUpperCase();\n}","import {Curve, findEndTime, findStartTime, throwErrorIfEmpty} from \"./curves/curve\";\nimport {StepSection} from \"./curves/sections/step\";\nimport {Section} from \"./curves/sections/section\";\nimport {Container} from \"pixi.js\";\n\nexport const CAMERA_ID_PREFIX = \"CAMERA_\";\nexport const CAMERA_DEFAULT_ID = \"CAMERA_DEFAULT\";\nexport const CAMERA_HUD_ID = \"CAMERA_HUD\";\n\nexport enum CameraAttribute {\n    X,\n    Y,\n    ROTATION_DEG,\n    ZOOM,\n}\n\nexport function stringify(a: CameraAttribute): string {\n    return CameraAttribute[a]\n}\n\nexport function isCamera(entityId: string): boolean {\n    return entityId.startsWith(CAMERA_ID_PREFIX)\n}\n\nexport class Camera {\n    id: string;\n    width: number;\n    height: number;\n\n    x = new Curve<number>();\n    y = new Curve<number>();\n    rotation = new Curve<number>();\n    zoom = new Curve<number>();\n\n\n    startTime: number = 0;\n\n    constructor(id: string, width: number, height: number) {\n        this.id = id;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     * Call after all curves are set. This will setup all necessary\n     * things such as initialize empty curves to default values.\n     *\n     * if the mandatory curves don't have at least one Section,\n     * this method will throw an error. */\n    finishSetup() {\n        // Some curves should not be empty when initialized.\n        throwErrorIfEmpty(this.x, 'x');\n        throwErrorIfEmpty(this.y, 'y');\n\n        this.startTime = this.getStartTime();\n\n        // Set default values for empty curves.\n        if (this.rotation.isEmpty()) {\n            this.rotation.add(new StepSection(this.startTime, 0));\n        }\n        if (this.zoom.isEmpty()) {\n            this.zoom.add(new StepSection(this.startTime, 1));\n        }\n    }\n\n    update(time: number, viewport: Container, screenHeight: number, worldToScreen: number) {\n        let x = this.x.getValue(time) * worldToScreen;\n        let y = screenHeight - this.y.getValue(time) * worldToScreen;\n        let width = this.width * worldToScreen;\n        let height = this.height * worldToScreen;\n        viewport.position.set(width / 2, height / 2);\n        viewport.pivot.set(x, y);\n        viewport.angle = this.rotation.getValue(time);\n        viewport.scale.set(this.zoom.getValue(time));\n    }\n\n    addSection(attribute: string, section: Section<any>) {\n        switch (attribute) {\n            case stringify(CameraAttribute.X):\n                this.x.add(section);\n                return;\n            case stringify(CameraAttribute.Y):\n                this.y.add(section);\n                return;\n            case stringify(CameraAttribute.ROTATION_DEG):\n                this.rotation.add(section);\n                return;\n            case stringify(CameraAttribute.ZOOM):\n                this.zoom.add(section);\n                return;\n        }\n    }\n\n    private getAttributes(): Curve<any>[] {\n        return [this.x, this.y, this.rotation, this.zoom];\n    }\n\n    getEndTime(): number {\n        return findEndTime(this.getAttributes());\n    }\n\n    getStartTime(): number {\n        return findStartTime(this.getAttributes());\n    }\n}\n\nexport function createCenteredCamera(id: string, width: number, height: number): Camera {\n    let camera = new Camera(id, width, height);\n    camera.addSection(stringify(CameraAttribute.X), new StepSection(0, width / 2));\n    camera.addSection(stringify(CameraAttribute.Y), new StepSection(0, height / 2));\n    camera.finishSetup();\n    return camera;\n}","import {Section} from \"./curves/sections/section\";\nimport {Attachable} from \"./attachable\";\nimport {Curve} from \"./curves/curve\";\nimport {Assets} from \"./assets\";\n\nexport const HUD_ID_PREFIX = \"HUD_\";\n\nexport function isOnHUD(entityId: string): boolean {\n    return entityId.startsWith(HUD_ID_PREFIX)\n}\n\nexport interface Entity {\n\n    id: string;\n\n    attachable: Attachable;\n\n    // After all sections are loaded finish\n    // with setting things up\n    finishSetup(assets: Assets): void;\n\n    // Update the entity attributes based\n    // on provided time\n    update(time: number, delta: number, assets: Assets, screenHeight: number, worldToScreen: number);\n\n    // Add a new section to a specified attribute.\n    addSection(attribute: string, section: Section<any>);\n\n    // Finds a curve based on the attribute path\n    getCurve(attribute: string): Curve<any>;\n\n    // Get the last section time of all the\n    // sections in this entity\n    getEndTime(): number;\n\n    // Get the first section time of all the\n    // sections in this entity\n    getStartTime(): number;\n\n}","import {errorIfUndefined, Section} from \"./section\";\nimport {round} from \"../../math/round\";\n\n/**\n * A sections representing a simple textDisplay function,\n * where the values are strings.\n */\nexport class TextSection extends Section<string> {\n\n    static readonly NAME: string = \"TextSection\";\n\n    getValue(_time: number, prevSection: Section<string>): string {\n        return prevSection.endRangeValue;\n    }\n\n    static parse(dict: any): TextSection {\n        errorIfUndefined([dict.endTime, dict.text]);\n        return new TextSection(dict.endTime, dict.text);\n    }\n\n    static toDict(entityId: string, attribute: string, endTime: number, text: string): object {\n        return {\n            \"type\": TextSection.name,\n            \"entityId\": entityId,\n            \"attribute\": attribute,\n            \"endTime\": round(endTime, 3),\n            \"text\": text\n        };\n    }\n}","import {Curve, findEndTime, findStartTime, throwErrorIfEmpty} from \"./curves/curve\";\nimport {Text} from \"pixi.js\";\nimport {StepSection} from \"./curves/sections/step\";\nimport {Section} from \"./curves/sections/section\";\nimport {Attach} from \"./attachSection\";\nimport {Attachable} from \"./attachable\";\nimport {TextSection} from \"./curves/sections/text\";\nimport {Entity, HUD_ID_PREFIX} from \"./entity\";\nimport {BooleanSection} from \"./curves/sections/boolean\";\nimport {Assets} from \"./assets\";\n\nexport const TEXT_ID_PREFIX = \"TEXT_\";\n\nexport enum TextEntityAttribute {\n    TEXT,\n    NUMBER_TEXT,\n    NUMBER_TEXT_DEC,\n    X,\n    Y,\n    COLOR,\n    ANCHOR_X,\n    ANCHOR_Y,\n    FONT_SIZE,\n    FONT_FAMILY,\n    FONT_STYLE,\n    FONT_WEIGHT,\n    ROTATION_DEG,\n    OPACITY,\n    VISIBILITY,\n    SCALE,\n    LAYER,\n    ATTACH\n}\n\nexport function stringify(a: TextEntityAttribute): string {\n    return TextEntityAttribute[a]\n}\n\nexport function isTextEntity(entityId: string): boolean {\n    return entityId.startsWith(TEXT_ID_PREFIX) || entityId.startsWith(HUD_ID_PREFIX + TEXT_ID_PREFIX)\n}\n\nexport class TextEntity implements Entity {\n    id: string;\n\n    textDisplay = new Text(\"\");\n\n    text = new Curve<string>();\n    // If not empty it is used instead of text\n    numberText = new Curve<number>();\n    numberTextDecimals = new Curve<number>();\n\n    x = new Curve<number>();\n    y = new Curve<number>();\n    color = new Curve<string>();\n    anchorX = new Curve<number>();\n    anchorY = new Curve<number>();\n    fontSize = new Curve<number>();\n    fontFamily = new Curve<string>();\n    fontStyle = new Curve<string>();\n    fontWeight = new Curve<string>();\n    rotation = new Curve<number>();\n    visibility = new Curve<boolean>();\n    scale = new Curve<number>();\n    // Defines to which other entity and how this\n    // entity is attached (if to any).\n    attach = new Curve<Attach>();\n    layer = new Curve<number>();\n    opacity = new Curve<number>();\n\n    // If this entity is attached to another entity\n    // it can calculate the attributes of this entity\n    // based on the entity it is attached to.\n    attachable: Attachable;\n\n    startTime: number = 0;\n\n    constructor(id: string, getEntity: (id: string) => (Attachable | undefined)) {\n        this.id = id;\n        this.attachable = new Attachable(this.x, this.y, this.rotation,\n            this.visibility, this.scale, this.attach, getEntity);\n    }\n\n    /**\n     * Call after all curves are set. This will setup all necessary\n     * things such as initialize empty curves to default values.\n     *\n     * if the mandatory curves don't have at least one Section,\n     * this method will throw an error. */\n    finishSetup(_assets: Assets) {\n        // Some curves should not be empty when initialized.\n        // At least one of either text or numberText should not be empty.\n        try {\n            throwErrorIfEmpty(this.text, 'text');\n        } catch (e) {\n            throwErrorIfEmpty(this.numberText, 'numberText');\n        }\n        throwErrorIfEmpty(this.x, 'x');\n        throwErrorIfEmpty(this.y, 'y');\n\n        this.startTime = this.getStartTime();\n        let t = this.startTime;\n\n        // Set default values for empty curves.\n        if (!this.numberText.isEmpty() && this.numberTextDecimals.isEmpty()) {\n            this.numberTextDecimals.add(new StepSection(t, 2));\n        }\n        if (this.color.isEmpty()) {\n            this.color.add(new TextSection(t, \"#FFFFFF\"));\n        }\n        if (this.anchorX.isEmpty()) {\n            this.anchorX.add(new StepSection(t, 0.5));\n        }\n        if (this.anchorY.isEmpty()) {\n            this.anchorY.add(new StepSection(t, 0.5));\n        }\n        if (this.fontSize.isEmpty()) {\n            this.fontSize.add(new StepSection(t, 26));\n        }\n        if (this.fontFamily.isEmpty()) {\n            this.fontFamily.add(new TextSection(t, \"Arial\"));\n        }\n        if (this.fontWeight.isEmpty()) {\n            this.fontWeight.add(new TextSection(t, \"normal\"));\n        }\n        if (this.fontStyle.isEmpty()) {\n            this.fontStyle.add(new TextSection(t, \"normal\"));\n        }\n        if (this.rotation.isEmpty()) {\n            this.rotation.add(new StepSection(t, 0));\n        }\n        if (this.visibility.isEmpty()) {\n            this.visibility.add(new BooleanSection(t, true));\n        }\n        if (this.scale.isEmpty()) {\n            this.scale.add(new StepSection(t, 1));\n        }\n        if (this.layer.isEmpty()) {\n            this.layer.add(new StepSection(t, 1));\n        }\n        if (this.opacity.isEmpty()) {\n            this.opacity.add(new StepSection(this.startTime, 1));\n        }\n    }\n\n    update(time: number, delta: number, assets: Assets, screenHeight: number, worldToScreen: number) {\n        if (time < this.startTime) {\n            this.textDisplay.visible = false;\n            return;\n        }\n\n        this.textDisplay.visible = this.attachable.getVisibility(time);\n        if (!this.textDisplay.visible) {\n            return;\n        }\n\n        this.textDisplay.text = (this.numberText.isEmpty())\n            ? this.text.getValue(time)\n            : this.numberText.getValue(time).toFixed(this.numberTextDecimals.getValue(time));\n        [this.textDisplay.x, this.textDisplay.y] = this.attachable.getXY(time, screenHeight, worldToScreen);\n        this.textDisplay.style.fill = this.color.getValue(time);\n        this.textDisplay.anchor.x = this.anchorX.getValue(time);\n        this.textDisplay.anchor.y = this.anchorY.getValue(time);\n        this.textDisplay.style.fontSize = this.fontSize.getValue(time);\n        this.textDisplay.style.fontFamily = this.fontFamily.getValue(time);\n        this.textDisplay.style.fontWeight = this.fontWeight.getValue(time);\n        this.textDisplay.angle = -this.attachable.getAngle(time);\n        this.textDisplay.alpha = this.opacity.getValue(time);\n        this.textDisplay.zIndex = this.layer.getValue(time);\n        this.textDisplay.scale.set(this.attachable.getScale(time));\n    }\n\n    addSection(attribute: string, section: Section<any>) {\n        switch (attribute) {\n            case stringify(TextEntityAttribute.TEXT):\n                this.text.add(section);\n                return;\n            case stringify(TextEntityAttribute.NUMBER_TEXT):\n                this.numberText.add(section);\n                return;\n            case stringify(TextEntityAttribute.NUMBER_TEXT_DEC):\n                this.numberTextDecimals.add(section);\n                return;\n            case stringify(TextEntityAttribute.X):\n                this.x.add(section);\n                return;\n            case stringify(TextEntityAttribute.Y):\n                this.y.add(section);\n                return;\n            case stringify(TextEntityAttribute.COLOR):\n                this.color.add(section);\n                return;\n            case stringify(TextEntityAttribute.ANCHOR_X):\n                this.anchorX.add(section);\n                return;\n            case stringify(TextEntityAttribute.ANCHOR_Y):\n                this.anchorY.add(section);\n                return;\n            case stringify(TextEntityAttribute.FONT_SIZE):\n                this.fontSize.add(section);\n                return;\n            case stringify(TextEntityAttribute.FONT_FAMILY):\n                this.fontFamily.add(section);\n                return;\n            case stringify(TextEntityAttribute.FONT_STYLE):\n                this.fontStyle.add(section);\n                return;\n            case stringify(TextEntityAttribute.FONT_WEIGHT):\n                this.fontWeight.add(section);\n                return;\n            case stringify(TextEntityAttribute.ROTATION_DEG):\n                this.rotation.add(section);\n                return;\n            case stringify(TextEntityAttribute.OPACITY):\n                this.opacity.add(section);\n                return;\n            case stringify(TextEntityAttribute.VISIBILITY):\n                this.visibility.add(section);\n                return;\n            case stringify(TextEntityAttribute.SCALE):\n                this.scale.add(section);\n                return;\n            case stringify(TextEntityAttribute.LAYER):\n                this.layer.add(section);\n                return;\n            case stringify(TextEntityAttribute.ATTACH):\n                this.attach.add(section);\n                return;\n        }\n    }\n\n    getCurve(attribute: string): Curve<any> {\n        switch (attribute) {\n            case stringify(TextEntityAttribute.TEXT):\n                return this.text;\n            case stringify(TextEntityAttribute.NUMBER_TEXT):\n                return this.numberText;\n            case stringify(TextEntityAttribute.NUMBER_TEXT_DEC):\n                return this.numberTextDecimals;\n            case stringify(TextEntityAttribute.X):\n                return this.x;\n            case stringify(TextEntityAttribute.Y):\n                return this.y;\n            case stringify(TextEntityAttribute.COLOR):\n                return this.color;\n            case stringify(TextEntityAttribute.ANCHOR_X):\n                return this.anchorX;\n            case stringify(TextEntityAttribute.ANCHOR_Y):\n                return this.anchorY;\n            case stringify(TextEntityAttribute.FONT_SIZE):\n                return this.fontSize;\n            case stringify(TextEntityAttribute.FONT_FAMILY):\n                return this.fontFamily;\n            case stringify(TextEntityAttribute.FONT_STYLE):\n                return this.fontStyle;\n            case stringify(TextEntityAttribute.FONT_WEIGHT):\n                return this.fontWeight;\n            case stringify(TextEntityAttribute.ROTATION_DEG):\n                return this.rotation;\n            case stringify(TextEntityAttribute.OPACITY):\n                return this.opacity;\n            case stringify(TextEntityAttribute.VISIBILITY):\n                return this.visibility;\n            case stringify(TextEntityAttribute.SCALE):\n                return this.scale;\n            case stringify(TextEntityAttribute.LAYER):\n                return this.layer;\n            case stringify(TextEntityAttribute.ATTACH):\n                return this.attach;\n            default:\n                throw Error(`attribute ${attribute} is not valid`)\n        }\n    }\n\n    private getAttributes(): Curve<any>[] {\n        return [this.text, this.x, this.y, this.color, this.anchorX, this.numberText, this.numberTextDecimals,\n            this.anchorY, this.fontSize, this.fontFamily, this.fontStyle, this.fontWeight, this.rotation,\n            this.visibility, this.scale, this.attach, this.layer, this.opacity];\n    }\n\n    getEndTime(): number {\n        return findEndTime(this.getAttributes());\n    }\n\n    getStartTime(): number {\n        return findStartTime(this.getAttributes());\n    }\n}","import {errorIfUndefined} from \"./curves/sections/section\";\nimport {colorToNumber} from \"./util/color\";\n\n\nexport class GameDetails {\n\n    gameNamePretty: string;\n    gameName: string;\n    gameVersion: string;\n    assetsVersion: string;\n    backgroundColor: string;\n\n    camera: CameraSettings;\n    showEntityPath: ShowEntityPathSettings | null;\n\n    constructor(gameNamePretty: string, gameName: string, gameVersion: string, assetsVersion: string,\n                backgroundColor: string, camera: CameraSettings, showEntityPath: ShowEntityPathSettings | null) {\n        this.gameNamePretty = gameName;\n        this.gameName = gameName;\n        this.gameVersion = gameVersion;\n        this.assetsVersion = assetsVersion;\n        this.backgroundColor = backgroundColor;\n        this.camera = camera;\n        this.showEntityPath = showEntityPath;\n    }\n\n    static parse(dict: any): GameDetails {\n        errorIfUndefined([dict.gameNamePretty, dict.gameName, dict.gameVersion, dict.assetsVersion,\n            dict.backgroundColor, dict.camera, dict.showEntityPath]);\n\n        let showEntityPath = (dict.showEntityPath == null)\n            ? null\n            : ShowEntityPathSettings.parse(dict.showEntityPath);\n\n        return new GameDetails(\n            dict.gameNamePretty, dict.gameName, dict.gameVersion, dict.assetsVersion, dict.backgroundColor,\n            CameraSettings.parse(dict.camera),\n            showEntityPath\n        );\n    }\n}\n\nexport class CameraSettings {\n\n    width: number;\n    height: number;\n\n    constructor(width: number, height: number) {\n        this.width = width;\n        this.height = height;\n    }\n\n    static parse(dict: any): CameraSettings {\n        errorIfUndefined([dict.width, dict.height]);\n        return new CameraSettings(dict.width, dict.height);\n    }\n}\n\nexport class ShowEntityPathSettings {\n\n    pathColor: number;\n    pathAlpha: number;\n    clickedEntityTint: number;\n    pathWidth: number;\n    drawingTimeInterval: number;\n\n    constructor(pathColor: string, pathAlpha: number, clickedEntityTint: string, pathWidth: number, drawingTimeInterval: number) {\n        this.pathColor = colorToNumber(pathColor);\n        this.pathAlpha = pathAlpha;\n        this.clickedEntityTint = colorToNumber(clickedEntityTint);\n        this.pathWidth = pathWidth;\n        this.drawingTimeInterval = drawingTimeInterval;\n    }\n\n    static parse(dict: any): ShowEntityPathSettings {\n        errorIfUndefined([dict.pathColor, dict.pathAlpha, dict.clickedEntityTint,\n            dict.pathWidth, dict.drawingTimeInterval]);\n        return new ShowEntityPathSettings(dict.pathColor, dict.pathAlpha, dict.clickedEntityTint,\n            dict.pathWidth, dict.drawingTimeInterval);\n    }\n}","import {errorIfUndefined} from \"./curves/sections/section\";\n\nexport class MatchDetail {\n\n    description: string;\n    value: any;\n\n    constructor(description: string, value: any) {\n        this.description = description;\n        this.value = value;\n    }\n\n    static parse(dict: any): MatchDetail {\n        errorIfUndefined([dict.description, dict.value]);\n        return new MatchDetail(dict.description, dict.value);\n    }\n}","import {errorIfUndefined} from \"./curves/sections/section\";\nimport {Curve} from \"./curves/curve\";\n\n\nexport class Chart {\n\n    name: string;\n    series: ChartSeriesElement[];\n\n    constructor(name: string, series: ChartSeriesElement[]) {\n        this.name = name;\n        this.series = series;\n    }\n\n    static parse(dict: any): Chart {\n        errorIfUndefined([dict.name, dict.series]);\n        return new Chart(dict.name, dict.series);\n    }\n}\n\nexport class ChartSeriesElement {\n    name: string;\n    color: string;\n    curveRef: CurveRef;\n    curve: Curve<number> | null = null;\n\n    constructor(name: string, color: string, curveRef: CurveRef) {\n        this.name = name;\n        this.color = color;\n        this.curveRef = curveRef;\n    }\n\n    static parse(dict: any): ChartSeriesElement {\n        errorIfUndefined([dict.color, dict.name, dict.curveRef]);\n        return new ChartSeriesElement(dict.name, dict.color, dict.curveRef);\n    }\n}\n\nexport class CurveRef {\n    entityId: string;\n    attribute: string;\n\n    constructor(entityId: string, attribute: string) {\n        this.entityId = entityId;\n        this.attribute = attribute;\n    }\n\n    static parse(dict: any): CurveRef {\n        errorIfUndefined([dict.entityId, dict.attribute]);\n        return new CurveRef(dict.entityId, dict.attribute);\n    }\n}","import {errorIfUndefined, Section} from \"./section\";\nimport {round} from \"../../math/round\";\n\n/**\n * A sections representing a simple linear function.\n */\nexport class LinearSection extends Section<number> {\n\n    static readonly NAME: string = \"LinearSection\";\n\n    getValue(time: number, prevSection: Section<number>): number {\n        let sectionDuration = this.endTime - prevSection.endTime;\n        let elapsedDuration = time - prevSection.endTime;\n\n        let subsectionValue = (this.endRangeValue - prevSection.endRangeValue) * (elapsedDuration / sectionDuration);\n\n        return prevSection.endRangeValue + subsectionValue;\n    }\n\n    static parse(dict: any): LinearSection {\n        errorIfUndefined([dict.endTime, dict.endRangeValue]);\n        return new LinearSection(dict.endTime, dict.endRangeValue);\n    }\n\n    static toDict(entityId: string, attribute: string, endTime: number, endRangeValue: number): object {\n        return {\n            \"type\": LinearSection.name,\n            \"entityId\": entityId,\n            \"attribute\": attribute,\n            \"endTime\": round(endTime, 3),\n            \"endRangeValue\": round(endRangeValue, 3)\n        };\n    }\n}","/**\n * A sections representing a sine function.\n */\nimport {errorIfUndefined, Section} from \"./section\";\nimport {round} from \"../../math/round\";\nimport {SineEquation} from \"../../math/sineEquation\";\n\nexport class SineSection extends Section<number> {\n\n    static readonly NAME: string = \"SineSection\";\n\n    sine: SineEquation;\n\n    constructor(endTime: number, sine: SineEquation) {\n        super(endTime, sine.getValue(endTime));\n\n        this.sine = sine;\n    }\n\n    getValue(time: number, _prevSection: Section<number>): number {\n        return this.sine.getValue(time);\n    }\n\n    static parse(dict: any): SineSection {\n        errorIfUndefined([dict.endTime, dict.t0, dict.A, dict.r, dict.B, dict.C]);\n\n        let sine = new SineEquation(dict.t0, dict.A, dict.r, dict.B, dict.C);\n        return new SineSection(dict.endTime, sine);\n    }\n\n    static toDict(entityId: string, attribute: string, endTime: number, sine: SineEquation): object {\n        return {\n            \"type\": SineSection.name,\n            \"entityId\": entityId,\n            \"attribute\": attribute,\n            \"endTime\": round(endTime, 3),\n            \"t0\": round(sine.t0, 3),\n            \"A\": round(sine.A, 3),\n            \"r\": round(sine.r, 3),\n            \"B\": round(sine.B, 3),\n            \"C\": round(sine.C, 3),\n        };\n    }\n}","// NOTE: This curves section is not in curves library as it is specific\n//       to this replay viewer.\n\n\nimport {errorIfUndefined, Section} from \"./curves/sections/section\";\nimport {round} from \"./math/round\";\n\n/**\n * A sections representing an attach attribute which\n * makes one entity 'attach' to another.\n */\nexport class AttachSection extends Section<Attach> {\n\n    static readonly NAME: string = \"AttachSection\";\n\n    getValue(_time: number, prevSection: Section<Attach>): Attach {\n        return prevSection.endRangeValue;\n    }\n\n    static parse(dict: any): AttachSection {\n        errorIfUndefined([dict.endTime, dict.entityId, dict.attachToEntityId, dict.attachX, dict.attachY,\n            dict.attachRotation, dict.attachAngle, dict.attachScale, dict.attachVisibility]);\n\n        let attach = new Attach(dict.attachToEntityId, dict.attachX, dict.attachY, dict.attachRotation,\n            dict.attachAngle, dict.attachScale, dict.attachVisibility);\n        return new AttachSection(dict.endTime, attach);\n    }\n\n    static toDict(entityId: string, attribute: string, endTime: number, attach: Attach): object {\n        return {\n            \"type\": AttachSection.name,\n            \"entityId\": entityId,\n            \"attribute\": attribute,\n            \"endTime\": round(endTime, 3),\n            \"attachToEntityId\": attach.attachToEntityId,\n            \"attachX\": attach.attachX,\n            \"attachY\": attach.attachY,\n            \"attachRotation\": attach.attachRotation,\n            \"attachAngle\": attach.attachAngle,\n            \"attachScale\": attach.attachScale,\n            \"attachVisibility\": attach.attachVisibility\n        };\n    }\n}\n\nexport class Attach {\n    // TextureEntity to which to attach\n    attachToEntityId: string;\n\n    // Define which attributes to attach\n    attachX: boolean;\n    attachY: boolean;\n    attachRotation: boolean;\n    attachAngle: boolean;\n    attachScale: boolean;\n    attachVisibility: boolean;\n\n    constructor(entityId: string, attachX: boolean, attachY: boolean, attachRotation: boolean,\n                attachAngle: boolean, attachScale: boolean, attachVisibility: boolean) {\n        this.attachToEntityId = entityId;\n        this.attachX = attachX;\n        this.attachY = attachY;\n        this.attachRotation = attachRotation;\n        this.attachAngle = attachAngle;\n        this.attachScale = attachScale;\n        this.attachVisibility = attachVisibility;\n    }\n}","import {Curve, findEndTime, findStartTime, throwErrorIfEmpty} from \"./curves/curve\";\nimport {Container} from \"pixi.js\";\nimport {StepSection} from \"./curves/sections/step\";\nimport {Section} from \"./curves/sections/section\";\nimport {Attach} from \"./attachSection\";\nimport {Attachable} from \"./attachable\";\nimport {Entity, HUD_ID_PREFIX} from \"./entity\";\nimport {Emitter} from \"pixi-particles\";\nimport {BooleanSection} from \"./curves/sections/boolean\";\nimport {Assets} from \"./assets\";\n\nexport const PARTICLE_ID_PREFIX = \"PARTICLE_\";\n\nexport enum ParticleEntityAttribute {\n    X,\n    Y,\n    ROTATION_DEG,\n    LAYER,\n    OPACITY,\n    VISIBILITY,\n    SCALE,\n    ATTACH,\n    EFFECT,\n    EMIT\n}\n\nexport function stringify(a: ParticleEntityAttribute): string {\n    return ParticleEntityAttribute[a]\n}\n\nexport function isParticleEntity(entityId: string): boolean {\n    return entityId.startsWith(PARTICLE_ID_PREFIX) || entityId.startsWith(HUD_ID_PREFIX + PARTICLE_ID_PREFIX)\n}\n\nexport class ParticleEntity implements Entity {\n    id: string;\n\n    container = new Container();\n    emitter: Emitter | undefined;\n    effectDuration = 0;\n    defaultScale = 1;\n\n    x = new Curve<number>();\n    y = new Curve<number>();\n    rotation = new Curve<number>();\n    visibility = new Curve<boolean>();\n    scale = new Curve<number>();\n    // Defines to which other entity and how this\n    // entity is attached (if to any).\n    attach = new Curve<Attach>();\n    layer = new Curve<number>();\n    opacity = new Curve<number>();\n    effect = new Curve<string>();\n    emit = new Curve<boolean>();\n\n    // If this entity is attached to another entity\n    // it can calculate the attributes of this entity\n    // based on the entity it is attached to.\n    attachable: Attachable;\n\n    startTime: number = 0;\n\n    constructor(id: string, getEntity: (id: string) => (Attachable | undefined)) {\n        this.id = id;\n        this.attachable = new Attachable(this.x, this.y, this.rotation,\n            this.visibility, this.scale, this.attach, getEntity);\n    }\n\n    /**\n     * Call after all curves are set. This will setup all necessary\n     * things such as initialize empty curves to default values.\n     *\n     * if the mandatory curves don't have at least one Section,\n     * this method will throw an error. */\n    finishSetup(assets: Assets) {\n        // Some curves should not be empty when initialized.\n        throwErrorIfEmpty(this.x, 'x');\n        throwErrorIfEmpty(this.y, 'y');\n        throwErrorIfEmpty(this.effect, 'effect');\n        throwErrorIfEmpty(this.emit, 'emit');\n\n        this.startTime = this.getStartTime();\n        let t = this.startTime;\n\n        // Set default values for empty curves.\n        if (this.attachable.rotation.isEmpty()) {\n            this.attachable.rotation.add(new StepSection(t, 0));\n        }\n        if (this.layer.isEmpty()) {\n            this.layer.add(new StepSection(t, 1));\n        }\n        if (this.opacity.isEmpty()) {\n            this.opacity.add(new StepSection(t, 1));\n        }\n        if (this.attachable.visibility.isEmpty()) {\n            this.attachable.visibility.add(new BooleanSection(t, true));\n        }\n        if (this.attachable.scale.isEmpty()) {\n            this.attachable.scale.add(new StepSection(t, 1));\n        }\n        if (this.attachable.attach.isEmpty()) {\n            // Leave empty, it means this entity is not attached to any other entity\n        }\n\n        // Use only the first effect in effect curve\n        let effectName = this.effect.getValue(this.effect.getStartTime());\n        let effect = assets.loadedParticleEffects.get(effectName)!;\n        this.emitter = new Emitter(this.container, effect.textures, effect.settings);\n        this.defaultScale = effect.scale;\n        this.effectDuration = (this.emitter.emitterLifetime === -1)\n            ? -1\n            : this.emitter.emitterLifetime;\n    }\n\n    update(time: number, delta: number, assets: Assets, screenHeight: number, worldToScreen: number) {\n        if (time < this.startTime) {\n            this.container.visible = false;\n            return;\n        }\n        this.container.visible = this.attachable.getVisibility(time);\n        if (!this.container.visible) {\n            return;\n        }\n\n        [this.container.x, this.container.y] = this.attachable.getXY(time, screenHeight, worldToScreen);\n        this.container.angle = -this.attachable.getAngle(time);\n        this.container.alpha = this.opacity.getValue(time);\n        this.container.zIndex = this.layer.getValue(time);\n        this.container.scale.set(this.attachable.getScale(time) * this.defaultScale);\n\n        this.updateEmitter(time, delta);\n    }\n\n    updateEmitter(time: number, delta: number) {\n        let isEmitting = this.emit.getValue(time);\n        if (!isEmitting) {\n            // Cleanup particles if they exist\n            if (this.emitter!.particleCount > 0) {\n                this.emitter!.cleanup();\n                this.emitter!.emit = false;\n            }\n            return;\n        }\n\n        let emitTime = this.emit.getPreviousSectionEndTime(time);\n        let emitEndTime = this.emit.getCurrentSectionEndTime(time);\n        let previousTime = time - delta;\n        let elapsedTime = time - emitTime;\n\n        // Reconfigure emitter on big time jumps\n        if (previousTime < emitTime || (emitEndTime !== null && previousTime >= emitEndTime)) {\n            this.emitter!.cleanup();\n            this.emitter!.emit = false;\n            this.emitter!.playOnce();\n            this.emitter!.update(time - emitTime);\n        } else {\n            // Reconfigure emitter when it is already finished but need to emmit again\n            // (when playing backwards)\n            if (!this.emitter!.emit && elapsedTime < this.emitter!.emitterLifetime) {\n                this.emitter!.cleanup();\n                this.emitter!.emit = false;\n                this.emitter!.playOnce();\n                this.emitter!.update(elapsedTime);\n            } else {\n                // When effect is continuous don't play it in reverse as\n                // it will only play in reverse the existing particles\n                // and not the ones emitted before and that were\n                // already removed. Simply play it forwards.\n                let updateDelta = (this.effectDuration === -1)\n                    ? Math.abs(delta)\n                    : delta;\n                this.emitter!.update(updateDelta);\n            }\n        }\n    }\n\n    addSection(attribute: string, section: Section<any>) {\n        switch (attribute) {\n            case stringify(ParticleEntityAttribute.X):\n                this.x.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.Y):\n                this.y.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.ROTATION_DEG):\n                this.attachable.rotation.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.LAYER):\n                this.layer.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.OPACITY):\n                this.opacity.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.VISIBILITY):\n                this.attachable.visibility.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.SCALE):\n                this.attachable.scale.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.ATTACH):\n                this.attachable.attach.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.EMIT):\n                this.emit.add(section);\n                return;\n            case stringify(ParticleEntityAttribute.EFFECT):\n                this.effect.add(section);\n                return;\n        }\n    }\n\n    getCurve(attribute: string): Curve<any> {\n        switch (attribute) {\n            case stringify(ParticleEntityAttribute.X):\n                return this.x;\n            case stringify(ParticleEntityAttribute.Y):\n                return this.y;\n            case stringify(ParticleEntityAttribute.ROTATION_DEG):\n                return this.rotation;\n            case stringify(ParticleEntityAttribute.LAYER):\n                return this.layer;\n            case stringify(ParticleEntityAttribute.OPACITY):\n                return this.opacity;\n            case stringify(ParticleEntityAttribute.VISIBILITY):\n                return this.visibility;\n            case stringify(ParticleEntityAttribute.SCALE):\n                return this.scale;\n            case stringify(ParticleEntityAttribute.ATTACH):\n                return this.attach;\n            case stringify(ParticleEntityAttribute.EMIT):\n                return this.emit;\n            case stringify(ParticleEntityAttribute.EFFECT):\n                return this.effect;\n            default:\n                throw Error(`attribute ${attribute} is not valid`)\n        }\n    }\n\n    private getAttributes(): Curve<any>[] {\n        return [this.attachable.x, this.attachable.y, this.attachable.rotation, this.effect, this.layer, this.opacity,\n            this.attachable.visibility, this.attachable.scale, this.attachable.attach, this.effect, this.emit];\n    }\n\n    getEndTime(): number {\n        return findEndTime(this.getAttributes());\n    }\n\n    getStartTime(): number {\n        return findStartTime(this.getAttributes());\n    }\n}\n","import {errorIfUndefined} from \"./curves/sections/section\";\n\nexport class BotDetails {\n\n    botName: string;\n    teamIndex: number;\n    color: string;\n    rank: number;\n    totalCpuTime: number;\n    numberOfTimeouts: number;\n    disqualified: boolean;\n    disqualificationTime: number;\n    disqualificationReason: string;\n\n    constructor(botName: string,\n                teamIndex: number,\n                color: string,\n                rank: number,\n                totalCpuTime: number,\n                numberOfTimeouts: number,\n                disqualified: boolean,\n                disqualificationTime: number,\n                disqualificationReason: string) {\n        this.botName = botName;\n        this.teamIndex = teamIndex;\n        this.color = color;\n        this.rank = rank;\n        this.totalCpuTime = totalCpuTime;\n        this.numberOfTimeouts = numberOfTimeouts;\n        this.disqualified = disqualified;\n        this.disqualificationTime = disqualificationTime;\n        this.disqualificationReason = disqualificationReason;\n    }\n\n    static parse(dict: any): BotDetails {\n        errorIfUndefined([dict.botName, dict.teamIndex, dict.color, dict.rank, dict.totalCpuTime,\n            dict.numberOfTimeouts, dict.disqualified, dict.disqualificationTime, dict.disqualificationReason]);\n        return new BotDetails(dict.botName, dict.teamIndex, dict.color, dict.rank, dict.totalCpuTime,\n            dict.numberOfTimeouts, dict.disqualified, dict.disqualificationTime, dict.disqualificationReason);\n    }\n}","import {GameDetails} from \"./gameDetails\";\nimport {MatchDetail} from \"./matchDetails\";\nimport {Entity} from \"./entity\";\nimport {Camera, isCamera} from \"./camera\";\nimport {Curve} from \"./curves/curve\";\nimport {Chart, ChartSeriesElement} from \"./chart\";\nimport {errorIfUndefined, Section} from \"./curves/sections/section\";\nimport {isTextEntity, TextEntity} from \"./textEntity\";\nimport {TextureEntity} from \"./textureEntity\";\nimport {StepSection} from \"./curves/sections/step\";\nimport {LinearSection} from \"./curves/sections/linear\";\nimport {SineSection} from \"./curves/sections/sine\";\nimport {TextSection} from \"./curves/sections/text\";\nimport {AttachSection} from \"./attachSection\";\nimport {BooleanSection} from \"./curves/sections/boolean\";\nimport {isParticleEntity, ParticleEntity} from \"./particleEntity\";\nimport {BotDetails} from \"./botDetails\";\n\n\nconst SUPPORTED_SECTION_TYPES = [\n    BooleanSection,\n    StepSection,\n    LinearSection,\n    SineSection,\n    TextSection,\n    AttachSection\n];\n\nconst STANDALONE_CURVE_ID_PREFIX = \"CURVE_\";\n\nexport class ParsedReplay {\n    gameDetails: GameDetails;\n    matchDetails: MatchDetail[];\n    botDetails: BotDetails[];\n    teamsFinalOrder: number[];\n    charts: Chart[] = [];\n    entities = new Map<string, Entity>();\n    cameras = new Map<string, Camera>();\n    standaloneCurves = new Map<string, Curve<any>>();\n\n    constructor(gameDetails: GameDetails,\n                matchDetails: MatchDetail[],\n                botDetails: BotDetails[],\n                teamsFinalOrder: number[],\n                charts: Chart[],\n                entities: Map<string, Entity>,\n                cameras: Map<string, Camera>,\n                standaloneCurves: Map<string, Curve<any>>) {\n        this.gameDetails = gameDetails;\n        this.matchDetails = matchDetails;\n        this.botDetails = botDetails;\n        this.teamsFinalOrder = teamsFinalOrder;\n        this.entities = entities;\n        this.cameras = cameras;\n        this.standaloneCurves = standaloneCurves;\n        this.charts = charts;\n    }\n\n    static parse(dict: any): ParsedReplay {\n        errorIfUndefined([dict.gameDetails, dict.matchDetails, dict.charts, dict.sections]);\n\n        let gameDetails = GameDetails.parse(dict.gameDetails);\n\n        // Parse sections\n        let [cameraWidth, cameraHeight] = [gameDetails.camera.width, gameDetails.camera.height];\n        let [entities, cameras, standaloneCurves] = parseSections(dict.sections, cameraWidth, cameraHeight);\n\n        // Parse charts\n        let charts: Chart[] = [];\n        dict.charts.forEach(chart => {\n            charts.push(Chart.parse(chart));\n        });\n        linkChartsWithCurves(charts, standaloneCurves, entities);\n\n        // Parse match details\n        let matchDetails: MatchDetail[] = [];\n        dict.matchDetails.forEach(detail => {\n            matchDetails.push(MatchDetail.parse(detail));\n        });\n\n        // Parse bot details\n        let botDetails: BotDetails[] = [];\n        dict.botDetails.forEach(detail => {\n            botDetails.push(BotDetails.parse(detail));\n        });\n\n        let teamsFinalOrderLength = (dict.teamsFinalOrder as number[]).length;\n        if (teamsFinalOrderLength !== botDetails.length) {\n            console.warn(`Length of teamsFinalOrder (${teamsFinalOrderLength}) should be the same `\n                + `as the length of the botsDetails (${botDetails.length})`);\n        }\n\n        return new ParsedReplay(\n            gameDetails,\n            matchDetails,\n            botDetails,\n            dict.teamsFinalOrder,\n            charts,\n            entities,\n            cameras,\n            standaloneCurves\n        );\n    }\n\n    getUniqueTexturePaths(): Set<string> {\n        return getUniqueTexturePaths(this.entities);\n    }\n\n    getUniqueParticleEffects(): Set<string> {\n        return getUniqueParticleEffects(this.entities);\n    }\n\n    getEndTime(): number {\n        return getEndTime(this.entities, this.cameras, this.standaloneCurves);\n    }\n}\n\nfunction parseSections(sections: JSON, cameraWidth: number, cameraHeight: number):\n    [Map<string, Entity>, Map<string, Camera>, Map<string, Curve<any>>] {\n\n    let entities = new Map<string, Entity>();\n    let cameras = new Map<string, Camera>();\n    let standaloneCurves = new Map<string, Curve<any>>();\n\n    (sections as any).forEach(sectionRaw => {\n\n        // Try parsing this section\n        try {\n            // Find the correct Section\n            let section: Section<any>;\n            for (let sectionType of SUPPORTED_SECTION_TYPES) {\n                if (sectionRaw.type === sectionType.NAME) {\n                    section = sectionType.parse(sectionRaw);\n                    break;\n                }\n            }\n\n            let entityId = sectionRaw.entityId;\n\n            if (isStandaloneCurve(entityId)) {\n                let curveId = entityId;\n                if (!standaloneCurves.has(curveId)) {\n                    standaloneCurves.set(curveId, new Curve<any>());\n                }\n                let curve = standaloneCurves.get(curveId)!;\n                curve.add(section!);\n            } else if (isCamera(entityId)) {\n                // Camera\n\n                // If the cameraIndex with provided id does not exist, create it\n                if (!cameras.has(entityId)) {\n                    let camera = new Camera(entityId, cameraWidth, cameraHeight);\n                    cameras.set(entityId, camera);\n                }\n\n                // Add curve sections to entity\n                let camera = cameras.get(entityId)!;\n                camera.addSection(sectionRaw.attribute, section!);\n            } else {\n                // Entity\n\n                // If the entity with provided id does not exist, create it\n                if (!entities.has(entityId)) {\n                    let getEntity = (id: string) => {\n                        return entities.get(id)!.attachable\n                    };\n\n\n                    let entity: Entity;\n                    if (isTextEntity(entityId)) entity = new TextEntity(entityId, getEntity);\n                    else if (isParticleEntity(entityId)) entity = new ParticleEntity(entityId, getEntity);\n                    else entity = new TextureEntity(entityId, getEntity);\n\n                    entities.set(entityId, entity);\n                }\n\n                // Add curve sections to entity\n                let entity = entities.get(entityId)!;\n                entity.addSection(sectionRaw.attribute, section!);\n            }\n        }\n        catch (e) {\n            e.message += `\\nRaw section: ${JSON.stringify(sectionRaw)}`;\n            throw e;\n        }\n    });\n\n    return [entities, cameras, standaloneCurves];\n}\n\nfunction isStandaloneCurve(entityId: string): boolean {\n    return entityId.startsWith(STANDALONE_CURVE_ID_PREFIX)\n}\n\nfunction linkChartsWithCurves(statistics: Chart[],\n                              standaloneCurves: Map<string, Curve<any>>,\n                              entities: Map<string, Entity>) {\n    statistics.forEach((statistic: Chart) => {\n        statistic.series.forEach(((s: ChartSeriesElement) => {\n            let ref = s.curveRef;\n            if (isStandaloneCurve(ref.entityId)) {\n                s.curve = standaloneCurves.get(ref.entityId)!;\n            } else {\n                let entity = entities.get(ref.entityId)!;\n                s.curve = entity.getCurve(ref.attribute);\n            }\n        }));\n    });\n}\n\nexport function getUniqueTexturePaths(entities: Map<string, Entity>): Set<string> {\n    let paths = new Set<string>();\n\n    entities.forEach((entity: Entity) => {\n        if (entity instanceof TextureEntity) {\n            entity.texture.sections.forEach((section: Section<string>) => {\n                if (!paths.has(section.endRangeValue)) {\n                    paths.add(section.endRangeValue);\n                }\n            })\n        }\n    });\n\n    return paths;\n}\n\nexport function getUniqueParticleEffects(entities: Map<string, Entity>): Set<string> {\n    let paths = new Set<string>();\n\n    entities.forEach((entity: Entity) => {\n        if (entity instanceof ParticleEntity) {\n            entity.effect.sections.forEach((section: Section<string>) => {\n                if (!paths.has(section.endRangeValue)) {\n                    paths.add(section.endRangeValue);\n                }\n            })\n        }\n    });\n\n    return paths;\n}\n\n\nfunction getEndTime(entities: Map<string, Entity>,\n                    cameras: Map<string, Camera>,\n                    standaloneCurves: Map<string, Curve<any>>): number {\n    let endTimeMax = 0;\n    entities.forEach((entity: Entity) => {\n        let endTime = entity.getEndTime();\n        if (endTime > endTimeMax) endTimeMax = endTime;\n    });\n    cameras.forEach((camera: Camera) => {\n        let endTime = camera.getEndTime();\n        if (endTime > endTimeMax) endTimeMax = endTime;\n    });\n    standaloneCurves.forEach((curve: Curve<any>) => {\n        let endTime = curve.getEndTime();\n        if (endTime > endTimeMax) endTimeMax = endTime;\n    });\n    return endTimeMax;\n}","import {Application, Container, Graphics} from \"pixi.js\";\nimport {registerOnEntityClickShowPath, TextureEntity} from \"./textureEntity\";\nimport {colorToNumber} from './util/color';\nimport {Camera, CAMERA_HUD_ID, CAMERA_DEFAULT_ID, createCenteredCamera} from \"./camera\";\nimport {Entity, isOnHUD} from \"./entity\";\nimport {TextEntity} from \"./textEntity\";\nimport {Chart} from \"./chart\";\nimport {MatchDetail} from \"./matchDetails\";\nimport {ParsedReplay} from \"./parsedReplay\";\nimport {Assets, loadAssets} from \"./assets\";\nimport {ParticleEntity} from \"./particleEntity\";\nimport {BotDetails} from \"./botDetails\";\n\nexport class MatchViewerApplication extends Application {\n    matchDetails: MatchDetail[] | null = null;\n    botDetails: BotDetails[] | null = null;\n    teamsFinalOrder: number[] | null = null;\n    matchDuration: number = 0;\n    time: number = 0;\n    playbackSpeed: number = 1;\n    gameCameras: Camera[] = [];\n    currentCamera: Camera | undefined;\n    charts: Chart[] = [];\n}\n\n// Camera array ordered alphabetically.\nfunction toOrderedArrayOfCameras(camerasMap: Map<string, Camera>): Camera[] {\n    // Create array of cameras and sort it\n    let cameras: Camera[] = [];\n    camerasMap.forEach((camera: Camera) => cameras.push(camera));\n    cameras.sort((a: Camera, b: Camera) => a.id.toUpperCase().localeCompare(b.id.toUpperCase()));\n    return cameras;\n}\n\nexport function startGame(replayRaw: JSON, assetsBaseUrl: string): MatchViewerApplication {\n    const app = new MatchViewerApplication({\n        backgroundColor: 0x000,\n        width: 1920,\n        height: 1080\n    });\n    app.renderer.view.style.width = \"100%\";\n\n    // Game viewport holds all entities in\n    // the gameName and displays them\n    const gameViewport = new Container();\n    gameViewport.sortableChildren = true;\n    app.stage.addChild(gameViewport);\n\n    // Hud viewport holds all gameName UI\n    // entities and displays them.\n    const hudViewport = new Container();\n    hudViewport.sortableChildren = true;\n    app.stage.addChild(hudViewport);\n\n    // Load replay\n    let replay = ParsedReplay.parse(replayRaw);\n    let [entities, gameDetails] = [replay.entities, replay.gameDetails!];\n    app.matchDetails = replay.matchDetails;\n    app.botDetails = replay.botDetails;\n    app.teamsFinalOrder = replay.teamsFinalOrder;\n    app.charts = replay.charts;\n    app.renderer.backgroundColor = colorToNumber(gameDetails.backgroundColor);\n\n    // Setup alphabetically ordered array of gameCameras\n    app.gameCameras = toOrderedArrayOfCameras(replay.cameras);\n    app.gameCameras.forEach((camera: Camera) => camera.finishSetup());\n\n    // If no cameras were provided, create default camera and add it to cameras\n    if (app.gameCameras.length === 0) {\n        let defaultCamera = createCenteredCamera(CAMERA_DEFAULT_ID, gameDetails.camera.width, gameDetails.camera.height);\n        app.gameCameras.push(defaultCamera);\n    }\n\n    app.currentCamera = app.gameCameras[0];\n\n    // Create HUD camera\n    let hudCamera = createCenteredCamera(CAMERA_HUD_ID, gameDetails.camera.width, gameDetails.camera.height);\n    let screenHeight = app.renderer.height;\n    let hudToScreen = screenHeight / gameDetails.camera.height;\n    hudCamera!.update(app.time, hudViewport, screenHeight, hudToScreen);\n\n    let worldToScreen = screenHeight / gameDetails.camera.height;\n\n    // Get gameName duration\n    app.matchDuration = replay.getEndTime();\n\n    let assetPath = `${assetsBaseUrl}/${gameDetails.gameName}/assets/${gameDetails.assetsVersion}`;\n    let assets = new Assets(assetPath);\n\n    let onAssetsLoaded = () => {\n        try {\n            // Setup entities and add them to gameName or HUD viewport\n            entities.forEach((entity: Entity) => {\n                entity.finishSetup(assets);\n\n                let viewport = (isOnHUD(entity.id)) ? hudViewport : gameViewport;\n                if (entity instanceof TextureEntity) {\n                    viewport.addChild((entity.sprite));\n                } else if (entity instanceof TextEntity) {\n                    viewport.addChild((entity.textDisplay));\n                } else if (entity instanceof ParticleEntity) {\n                    viewport.addChild(entity.container);\n                }\n            });\n\n            // When TextureEntity is clicked, draw its path on the screen\n            const graphics = new Graphics();\n            gameViewport.addChild(graphics);\n            if (gameDetails.showEntityPath != null) {\n                let settings = gameDetails.showEntityPath!;\n                registerOnEntityClickShowPath(settings, entities, graphics, screenHeight, worldToScreen);\n            }\n\n            let prevTime = 0;\n\n            // Add main gameName function to be called every tick\n            app.ticker.add((deltaScale) => {\n                let delta = 0;\n\n                // If user manually changed time\n                if (app.time !== prevTime) {\n                    delta = app.time - prevTime;\n                }\n                // Normal gameName iteration\n                else {\n                    delta = (1 / 60) * deltaScale * app.playbackSpeed;\n                    app.time += delta;\n                }\n                // Check time bounds\n                if (app.time > app.matchDuration) app.time = app.matchDuration;\n                if (app.time < 0) app.time = 0;\n\n                prevTime = app.time;\n\n                // Update current gameName camera\n                app.currentCamera!.update(app.time, gameViewport, screenHeight, worldToScreen);\n\n                // Update entities\n                entities.forEach((entity: Entity) => {\n                    entity.update(app.time, delta, assets, screenHeight, worldToScreen)\n                });\n            });\n\n            // Start the ticker\n            app.start();\n        }\n        catch (e) {\n            console.error(`Failed to view replay: ${e}`)\n        }\n    };\n\n    // Load assets and call onAssetsLoaded when finished\n    loadAssets(replay, assets, onAssetsLoaded);\n\n    return app;\n}","import {Component, createRef, default as React, RefObject} from 'react';\nimport Fullscreen from 'react-full-screen';\nimport {Glyphicon} from 'react-bootstrap';\nimport {ReactBootstrapSlider} from 'react-bootstrap-slider';\nimport {MatchViewerApplication, startGame} from \"../match-viewer\";\nimport {round} from \"../match-viewer/math/round\";\nimport {Camera} from \"../match-viewer/camera\";\nimport * as Pako from \"pako\";\nimport * as JSZip from \"jszip\";\n\nexport interface MatchBaseProps {\n    /** json needs to be string; gzip and zip need to be ArrayBuffer */\n    replayFile: string | ArrayBuffer | null;\n    replayUrl: string | null;\n    loopMatch: boolean;\n    assetsBaseUrl: string;\n}\n\ninterface MatchBaseState {\n    app: MatchViewerApplication | null;\n    duration: number,\n    time: number,\n    playbackSpeed: number,\n    cameraIndex: number,\n    isPlaying: boolean,\n    insideSpeedSlider: boolean,\n    speedSliderTabId: number,\n    showCameras: boolean,\n    isFull: boolean,\n    overlayOpacity: number,\n    forceViewerWidth: string,\n    numberOfCameras: number,\n    errorMessage: string\n}\n\ninterface MatchBasicProps extends MatchBaseProps {\n    setApplication: ((app: MatchViewerApplication) => void) | null;\n}\n\nexport class MatchBasic extends Component<MatchBasicProps, {}> {\n\n    // Parses the replay file and displays the gameName\n    gameCanvas: HTMLDivElement | null = null;\n    timeUpdateInterval: any = null;\n\n    state: MatchBaseState = {\n        app: null,\n        duration: 0,\n        time: 0,\n        playbackSpeed: 1,\n        cameraIndex: 0,\n        isPlaying: true,\n        insideSpeedSlider: false,\n        speedSliderTabId: -1,\n        showCameras: false,\n        isFull: false,\n        overlayOpacity: 0,\n        forceViewerWidth: \"100%\",\n        numberOfCameras: 0,\n        errorMessage: \"\"\n    };\n\n    puiRef: RefObject<HTMLDivElement> = createRef();\n\n    componentDidMount = () => {\n        window.addEventListener(\"resize\", this.updateViewerWidth);\n\n        this.updateViewerWidth();\n\n        this.loadReplayAndStart();\n    };\n\n    componentWillUnmount = () => {\n        window.removeEventListener(\"resize\", this.updateViewerWidth);\n        if (this.state.app) {\n            this.state.app!.destroy(true);\n            this.setState({app: null});\n        }\n        if (this.timeUpdateInterval !== null) clearInterval(this.timeUpdateInterval);\n    };\n\n    loadReplayAndStart = async () => {\n        let response: Response | null = null;\n        let responseClone: Response | null = null;\n        let rawData: string | ArrayBuffer | null = null;\n\n        // Fetch from url\n        if (this.props.replayUrl !== null) {\n            let replayUrl = this.props.replayUrl;\n            response = await fetch(replayUrl);\n            responseClone = response.clone();\n        }\n        // Already loaded but not parsed replay data\n        else if (this.props.replayFile !== null) {\n            rawData = this.props.replayFile;\n        } else {\n            console.error(\"replayFile and replayUrl are both null\");\n            return;\n        }\n\n        let replay: JSON;\n\n        // Parse replay file\n        try {\n            try {\n                let data = (response !== null)\n                    ? await response.arrayBuffer()\n                    : rawData as ArrayBuffer;\n                try {\n                    // Try gzip\n                    replay = JSON.parse(Pako.inflate(new Uint8Array(data), {to: \"string\"}));\n                } catch (e) {\n                    // Try zip\n                    let replayFileZip = Object.values((await JSZip.loadAsync(data)).files)[0];\n                    replay = JSON.parse(await replayFileZip.async(\"text\"));\n                }\n            } catch (e) {\n                // Try plain json\n                let data = (responseClone !== null)\n                    ? await responseClone.text()\n                    : rawData as string;\n                replay = JSON.parse(data);\n            }\n\n            let app = startGame(replay!, this.props.assetsBaseUrl);\n            this.gameCanvas!.appendChild(app.view);\n            this.setState({\n                app: app,\n                duration: app.matchDuration\n            });\n\n            this.state.numberOfCameras = app.gameCameras.length;\n            this.onCameraChange(0);\n\n            this.timeUpdateInterval = setInterval(this.setTime, 10);\n\n            // Send back application application\n            if (this.props.setApplication != null) {\n                this.props.setApplication(app);\n            }\n        }\n        catch (e) {\n            console.error(`ERROR: ${e}`);\n            this.setState({errorMessage: \"Failed to view the replay. Check if the file is in the correct format.\"});\n        }\n    };\n\n    updateViewerWidth = () => {\n        let containerWidth = \"100%\";\n        const availableW = window.screen.width;\n        const availableH = window.screen.height - this.puiRef.current!.clientHeight;\n        const availableRatio = round(availableW / availableH, 2);\n        const viewerRatio = round(16 / 9, 2);\n\n        if (availableRatio > viewerRatio) {\n            containerWidth = (((availableH * viewerRatio) / availableW) * 100).toFixed(2) + \"%\";\n        }\n\n        if (containerWidth !== this.state.forceViewerWidth) {\n            this.setState({forceViewerWidth: containerWidth});\n        }\n    };\n\n    // Calls itself recursively and syncs gameName time and timeline\n    setTime = () => {\n        let app = this.state.app;\n\n        // this.app is null only when it is destroyed as this\n        // method is only called after this.app has been initialized\n        if (app == null) return;\n\n        let time = app.time;\n\n        if (this.props.loopMatch && time === this.state.duration) {\n            // Infinitely loop the match\n            app.time = 0;\n            if (!this.state.isPlaying) {\n                app.ticker.update();\n            }\n            this.setState({time: 0});\n        } else {\n            // Regular functionality\n            this.setState({time: time});\n        }\n    };\n\n    // When user picks new time via timeline\n    onChangeTime = (event) => {\n        let app = this.state.app;\n\n        if (app === null) return;\n\n        app.time = event.target.value;\n        if (!this.state.isPlaying) {\n            app.ticker.update();\n        }\n\n        this.setState({\n            time: event.target.value,\n        });\n    };\n\n    onTogglePlay = () => {\n        let app = this.state.app;\n\n        if (app === null) return;\n\n        if (this.state.isPlaying) {\n            //this.app!.stop();\n            app.playbackSpeed = 0;\n            this.setState({\n                isPlaying: false,\n            });\n        } else {\n            // this.app!.start();\n            app.playbackSpeed = this.state.playbackSpeed;\n            this.setState({\n                isPlaying: true,\n            });\n        }\n\n        // Overlay play/pause animation\n        this.setState({overlayOpacity: 0.7});\n        setTimeout(() => this.setState({overlayOpacity: 0}), 250);\n    };\n\n    onResetSpeed = () => {\n        let app = this.state.app;\n\n        if (app === null) return;\n\n        if (app) {\n            app.playbackSpeed = 1;\n        }\n        this.setState({\n            playbackSpeed: 1,\n            speedSliderTabId: 1\n        });\n    };\n\n    onSpeedChange = (event) => {\n        let app = this.state.app;\n\n        if (app === null) return;\n\n        if (app) {\n            app.playbackSpeed = event.target.value;\n        }\n        this.setState({\n            playbackSpeed: event.target.value,\n            speedSliderTabId: 1\n        });\n    };\n\n    onCameraChange = (camIndex) => {\n        let app = this.state.app;\n\n        if (app === null) return;\n\n        app.currentCamera = app.gameCameras[camIndex];\n        if (!this.state.isPlaying) {\n            app.ticker.update();\n        }\n        this.setState({cameraIndex: camIndex});\n    };\n\n    goFull = () => {\n        let app = this.state.app;\n\n        if (app === null) return;\n\n        let goFullScreen = !this.state.isFull;\n        this.setState({isFull: goFullScreen});\n    };\n\n    render() {\n        let component = this;\n        let {app} = this.state;\n\n        return (\n            <Fullscreen\n                enabled={this.state.isFull}\n                onChange={isFull => this.setState({isFull})}\n            >\n                {this.state.errorMessage !== \"\" ? <div> {this.state.errorMessage} </div> : null}\n                <div className={app === null ? \"cont-match-viewer viewer-not-loaded\" : \"cont-match-viewer\"}>\n\n                    {/* Displaying match */}\n                    <div className=\"row-match-viewer\">\n                        <div ref={(thisDiv) => {\n                            component.gameCanvas = thisDiv\n                        }}\n                             style={{width: (this.state.isFull ? this.state.forceViewerWidth : \"100%\")}}\n                        />\n                        {/*<div className=\"viewer-overlay\"/>*/}\n                        {this.state.overlayOpacity > 0\n                            ? <Glyphicon className=\"viewer-overlay-icon\" glyph={this.state.isPlaying ? \"play\" : \"pause\"}\n                                         style={{opacity: this.state.overlayOpacity}}/>\n                            : null\n                        }\n                    </div>\n\n                    {/* Replay viewer control buttons */}\n                    <div className=\"row-pui\" ref={this.puiRef}>\n                        {/* Timeline */}\n                        <div className=\"pui-timeline\">\n                            <ReactBootstrapSlider value={this.state.time} min={0} max={this.state.duration} step={0.01}\n                                                  change={this.onChangeTime} tooltip=\"hide\"/>\n                        </div>\n                        {/* Control buttons */}\n                        <div className=\"pui-buttons\">\n                            <div className=\"pui-btns-left\">\n\n                                {/* Play/pause buttons */}\n                                <div className=\"pui-btn\" onClick={this.onTogglePlay}>\n                                    {this.state.isPlaying ? (\n                                        <Glyphicon className=\"pui-btns-glyph\" glyph=\"pause\"/>\n                                    ) : (\n                                        <Glyphicon className=\"pui-btns-glyph\" glyph=\"play\"/>\n                                    )}\n                                </div>\n                                {/* Playback playbackSpeed controls */}\n                                <div className=\"pui-cont\"\n                                     onMouseEnter={() => this.setState({insideSpeedSlider: true})}\n                                     onMouseLeave={() => this.setState({insideSpeedSlider: false})}\n                                >\n                                    <div className=\"pui-btn pui-btn-wide\">\n                                        <span className=\"pui-text\">{this.state.playbackSpeed + \"x\"}</span>\n                                    </div>\n                                    {/* Playback playbackSpeed slider */}\n                                    {(app !== null) && (this.state.insideSpeedSlider || this.state.speedSliderTabId > 0) ? (\n                                        <div className=\"pui-speed-slider\"\n                                             tabIndex={this.state.speedSliderTabId}\n                                             onBlur={\n                                                 this.state.insideSpeedSlider ? undefined : (\n                                                     () => this.setState({\n                                                         insideSpeedSlider: false,\n                                                         speedSliderTabId: -1\n                                                     })\n                                                 )\n                                             }\n                                        >\n                                            <span className=\"pui-divider\"/>\n                                            <ReactBootstrapSlider\n                                                value={this.state.playbackSpeed}\n                                                min={-6}\n                                                max={6}\n                                                step={0.1}\n                                                change={this.onSpeedChange}\n                                                tooltip=\"hide\"\n                                            />\n                                            <span className=\"pui-divider\"/>\n                                            <span className=\"pui-btn\" onClick={this.onResetSpeed}>\n                                                <Glyphicon className=\"pui-btns-glyph\" glyph=\"refresh\"/>\n                                            </span>\n                                        </div>\n                                    ) : null}\n                                </div>\n                            </div>\n\n                            <div className=\"pui-btns-right\">\n\n                                {/* Cameras */}\n                                <div className=\"pui-cont\" onMouseEnter={() => this.setState({showCameras: true})}\n                                     onMouseLeave={() => this.setState({showCameras: false})}>\n                                    {(app !== null) && this.state.showCameras ? (\n                                        <div className=\"pui-cont pui-cameras\">\n                                            {app.gameCameras.map((camera: Camera, i: number) => {\n                                                return <div className=\"pui-btn\" key={i} onClick={() => this.onCameraChange(i)}\n                                                            style={this.state.cameraIndex === i ? {color: \"#facd3b\"} : {}}>\n                                                    <Glyphicon glyph=\"facetime-video\"/>\n                                                    <span className=\"pui-text\"> {i + 1}</span>\n                                                </div>;\n                                            })}\n                                            <span className=\"pui-divider\"/>\n                                        </div>\n                                    ) : null}\n                                    <div className=\"pui-btn\">\n                                        <Glyphicon className=\"pui-btns-glyph\" glyph=\"facetime-video\"/>\n                                        <span className=\"pui-text\">{\" \" + (this.state.cameraIndex + 1)}</span>\n                                    </div>\n                                </div>\n\n                                {/* Fullscreen */}\n                                <div className=\"pui-btn\" onClick={this.goFull}>\n                                    {this.state.isFull ? <Glyphicon className=\"pui-btns-glyph\" glyph=\"fullscreen\"/> :\n                                        <Glyphicon className=\"pui-btns-glyph\" glyph=\"fullscreen\"/>}\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </Fullscreen>\n        )\n    }\n}\n","import * as React from \"react\";\nimport {Component} from \"react\";\nimport ReactEcharts from \"echarts-for-react\";\nimport {Chart, ChartSeriesElement} from \"../match-viewer/chart\";\nimport {round} from \"../match-viewer/math/round\";\n\ninterface StatisticChartProps {\n    stat: Chart;\n    matchDuration: number;\n}\n\ninterface StatisticChartState {\n    time: number;\n}\n\n\nexport class StatisticChart extends Component<StatisticChartProps, StatisticChartState> {\n\n    render() {\n        const stat = this.props.stat;\n\n        // Create series of data\n        const series: Object[] = [];\n        stat.series.forEach(((s: ChartSeriesElement) => {\n\n            let data: [number, number][] = [];\n            for (let time = 0; time <= this.props.matchDuration; time += 0.1) {\n                data.push([time, round(s.curve!.getValue(time), 3)]);\n            }\n            series.push({\n                name: s.name,\n                type: \"line\",\n                itemStyle: {\n                    color: s.color\n                },\n                lineStyle: {\n                    width: 3\n                },\n                showSymbol: false,\n                data: data\n            });\n        }));\n\n        return (\n            <ReactEcharts style={{minWidth: \"300px\"}}\n                option={{\n                    // title: {\n                    //     top: \"4%\",\n                    //     text: stat.name + \"\"\n                    // },\n                    tooltip: {\n                        trigger: \"axis\"\n                    },\n                    legend: {\n                        type: \"scroll\",\n                        // top: \"15%\",\n                        data: stat.series.map((s: ChartSeriesElement) => {\n                            return s.name;\n                        })\n                    },\n                    grid: {\n                        left: \"0%\",\n                        right: \"0%\",\n                        bottom: \"0%\",\n                        top: \"12%\", // top: \"27%\",\n                        containLabel: true\n                    },\n                    xAxis: {\n                        type: \"value\",\n                        axisLabel: {\n                            showMaxLabel: false,\n                            formatter: '{value} s'\n                        },\n                        min: 0,\n                        max: this.props.matchDuration,\n                    },\n                    yAxis: {\n                        type: \"value\"\n                    },\n                    series: series\n                }}\n            />\n        )\n    }\n}","import * as React from \"react\";\nimport {Component} from \"react\";\nimport {BotDetails} from \"../match-viewer/botDetails\";\nimport {Col, Row} from \"react-bootstrap\";\n\ninterface BotDetailsViewProps {\n    botDetails: BotDetails[];\n}\n\ninterface BotDetailsViewState {\n    botIndex: number;\n}\n\nexport class BotDetailsView extends Component<BotDetailsViewProps, BotDetailsViewState> {\n\n    state: BotDetailsViewState = {\n        botIndex: 0\n    };\n\n    render() {\n        const {botDetails} = this.props;\n        const {botIndex} = this.state;\n        const details = botDetails[botIndex];\n\n        if (botDetails.length === 0) {\n            return null;\n        }\n\n        return (\n            <Col md={12}>\n                {/* Draw tabs */}\n                <Row className=\"bot-details-tabs\">\n                    {botDetails.map((details: BotDetails, i: number) => {\n                        return <div key={i}\n                                    className={(i === botIndex) ? \"bot-details-tabs-selected\" : \"\"}\n                                    style={{color: details.color}}\n                                    onClick={() => {this.setState({botIndex: i})}}>\n                            {details.botName}\n                        </div>\n                    })}\n                </Row>\n                <Row><hr style={{marginTop: \"0.5em\"}}/></Row>\n\n                {/* Draw content */}\n                <Row>Team index: {details.teamIndex}</Row>\n                <Row>Rank: {details.rank}</Row>\n                <Row>Used CPU time: {details.totalCpuTime} s</Row>\n                <Row>Number of timeouts: {details.numberOfTimeouts}</Row>\n                {\n                    (details.disqualified)\n                    ? <div>\n                        <Row>Disqualification time: {details.disqualificationTime} s</Row>\n                        <Row>Disqualification reason: {details.disqualificationReason}</Row>\n                      </div>\n                    : null\n                }\n            </Col>\n        )\n    }\n}","import * as React from \"react\";\nimport {Component} from \"react\";\nimport {MatchBaseProps, MatchBasic} from \"./MatchBasic\";\nimport {Col, Row} from \"react-bootstrap\";\nimport {MatchViewerApplication} from \"../match-viewer\";\nimport {round} from \"../match-viewer/math/round\";\nimport {Chart} from \"../match-viewer/chart\";\nimport {StatisticChart} from \"./StatisticChart\";\nimport {MatchDetail} from \"../match-viewer/matchDetails\";\nimport {BotDetails} from \"../match-viewer/botDetails\";\nimport {BotDetailsView} from \"./BotDetailsView\";\n\ninterface MatchAdvancedProps extends MatchBaseProps {}\n\ninterface MatchAdvancedState {\n    app: MatchViewerApplication | null;\n    matchDuration;\n}\n\nexport class MatchAdvanced extends Component<MatchAdvancedProps, MatchAdvancedState> {\n\n    state: MatchAdvancedState = {\n        app: null,\n        matchDuration: 0,\n    };\n\n    setApplication = (app: MatchViewerApplication) => {\n        this.setState({\n            app: app,\n            matchDuration: round(app.matchDuration, 0),\n        });\n    };\n\n    render() {\n        const {app, matchDuration} = this.state;\n\n        return (\n            <div className=\"match\">\n                <Row>\n                    {/* Match view */}\n                    <Col md={8}>\n                        <MatchBasic\n                            replayFile={this.props.replayFile}\n                            replayUrl={this.props.replayUrl}\n                            loopMatch={this.props.loopMatch}\n                            assetsBaseUrl={this.props.assetsBaseUrl}\n                            setApplication={this.setApplication}\n                        />\n                    </Col>\n\n                    <Col md={4}>\n                        {app != null\n                            ? <div>\n                                <Row>{this.getBotsVersus(app.botDetails!, app.teamsFinalOrder!)}</Row>\n                                <Row>Duration: {matchDuration} s</Row>\n\n                                {/* Match details */}\n                                {app!.matchDetails!.map((detail: MatchDetail, i: number) => {\n                                    return <Row key={i}>{detail.description}: {detail.value}</Row>\n                                })}\n\n                                {/* Bot details */}\n                                <Row>\n                                    <BotDetailsView botDetails={app.botDetails!}/>\n                                </Row>\n                            </div>\n                            : null\n                        }\n                    </Col>\n                </Row>\n\n                {/* Statistics */}\n                {app != null\n                    ? <div className=\"statistics\">\n                        <Row>\n                            {app!.charts.map((stat: Chart, i: number) => {\n                                return <Col md={4} key={i} className=\"statistic-col\">\n                                    <h3>{stat.name}</h3>\n                                    <StatisticChart\n                                        stat={stat}\n                                        matchDuration={matchDuration}\n                                    />\n                                </Col>;\n                            })}\n                        </Row>\n                    </div>\n                    : null\n                }\n            </div>\n        )\n    }\n\n    getBotsVersus = (botDetails: BotDetails[], teamsFinalOrder: number[]) : any => {\n\n        // Sort bots by teams and by the order of the teams\n        botDetails.sort((d1: BotDetails, d2: BotDetails): number => {\n            let b1TeamPlace = teamsFinalOrder.indexOf(d1.teamIndex);\n            let b2TeamPlace = teamsFinalOrder.indexOf(d2.teamIndex);\n            return b1TeamPlace - b2TeamPlace;\n        });\n\n        return <h3>{botDetails.map((details: BotDetails, i: number) => {\n            return <span key={i}>\n                <span style={{color: details.color, fontWeight: \"bold\"}}>{details.botName}</span>\n                <small>{\n                    (i < botDetails.length - 1)\n                        ? (details.teamIndex !== botDetails[i + 1].teamIndex)\n                            ? <span style={{padding: \"0.2em\"}}>\n                                {((details.teamIndex === teamsFinalOrder[0]) ? \" defeats \" : \" and \")}\n                            </span>\n                            : \", \"\n                        : null }\n                </small>\n            </span>;\n        })}</h3>\n    }\n}\n\n","import * as React from \"react\";\nimport {Component} from \"react\";\nimport {Button, Col, Grid, Row} from \"react-bootstrap\";\nimport {MatchAdvanced} from \"../_dependencies/components/MatchAdvanced\";\nimport {Redirect, RouteComponentProps} from \"react-router-dom\";\n\ninterface LocalMatchViewerProps extends RouteComponentProps<{}> {\n    assetsServerPort: number\n}\n\ninterface LocalMatchViewerState {\n    goBack: boolean\n}\n\nexport class LocalMatchViewer extends Component<LocalMatchViewerProps, LocalMatchViewerState> {\n\n    state: LocalMatchViewerState = {\n      goBack: false\n    };\n\n    home = () => {\n        this.setState({goBack: true});\n    };\n\n    render() {\n        if (this.state.goBack) {\n            this.props.history.push(this.props.location);\n            return <Redirect to={`/`} />;\n        }\n\n        const search = new URLSearchParams(this.props.location.search);\n        let replayUrl = search.get(\"replayUrl\");\n\n        let assetsUrl = (this.props.assetsServerPort === undefined)\n            ? `games`\n            : `http://localhost:${this.props.assetsServerPort}`;\n\n        return (\n            <Grid>\n                <Row>\n                    <Col md={12}>\n                        <h2>Local Match Viewer</h2>\n                        <Button onClick={this.home} className=\"btn btn-lg custom-btn\">Replays List</Button>\n                        <MatchAdvanced\n                            replayUrl={replayUrl}\n                            replayFile={null}\n                            loopMatch={false}\n                            assetsBaseUrl={assetsUrl}\n                        />\n                    </Col>\n                </Row>\n                <br/> {/* TODO Replace with css padding */}\n            </Grid>\n        )\n    }\n}","import * as React from \"react\";\nimport {Component} from \"react\";\nimport {Col, Grid, Image, Row} from \"react-bootstrap\";\nimport {Redirect, RouteComponentProps} from 'react-router-dom';\n\ninterface ReplayPickerProps extends RouteComponentProps<{}> {\n    assetsServerPort: number | undefined\n}\n\ninterface ReplayPickerState {\n    directoryItems: string[];\n    currentPath: string;\n    chosenReplayPath: string;\n}\n\nexport class ReplayPicker extends Component<ReplayPickerProps, ReplayPickerState> {\n\n    state: ReplayPickerState = {\n        directoryItems: [],\n        currentPath: \"\",\n        chosenReplayPath: \"\"\n    };\n\n    componentDidMount = () => {\n        this.navigate(this.state.currentPath, \"/\");\n    };\n\n    navigate = async (currentPath: string, item: string) => {\n        let path = \"\";\n        if (currentPath !== \"\") path += `${currentPath}`;\n        if (item !== \"\") path += `${item}`;\n\n        if (!item.endsWith(\"/\")) {\n            // It is a file and not a directory -> open LocalMatchViewer\n            this.setState({chosenReplayPath: path});\n            return;\n        }\n\n        let url = (this.props.assetsServerPort === undefined)\n            ? `replays${path}`\n            : `http://localhost:${this.props.assetsServerPort}${path}`;\n        let response = await fetch(url);\n        let text = await response.text();\n\n        let el = document.createElement( 'html' );\n        el.innerHTML = text;\n\n        let list = el.getElementsByTagName( 'a' );\n        let list2: string[] = [];\n\n        for (let i = 0; i < list.length; i++) {\n            let el = list.item(i);\n            list2.push(el!.innerText);\n        }\n        this.setState({\n            directoryItems: list2,\n            currentPath: currentPath + item\n        });\n    };\n\n    back = () => {\n        let currentPath = this.state.currentPath;\n        let newPath = \"\";\n        currentPath = currentPath.substr(0, currentPath.length - 1);\n        if (currentPath.lastIndexOf(\"/\") !== -1) {\n            newPath = currentPath.substr(0, currentPath.lastIndexOf(\"/\"));\n        }\n        this.navigate(newPath, \"/\");\n    };\n\n    render() {\n        const {directoryItems, chosenReplayPath, currentPath} = this.state;\n        const {assetsServerPort} = this.props;\n\n        if (chosenReplayPath !== \"\") {\n            this.props.history.push(this.props.location);\n            let replayUrl = (this.props.assetsServerPort === undefined)\n                ? `replays${chosenReplayPath}`\n                : `http://localhost:${assetsServerPort}${chosenReplayPath}`;\n            return <Redirect to={`/viewer?replayUrl=${replayUrl}`} />;\n        }\n\n        return (\n            <Grid>\n                <Row>\n                    <Col md={12}>\n                        <Row>\n                            <div id=\"logo\">\n                                <Image src=\"assets/logo-black-512.png\"/>\n                            </div>\n                        </Row>\n                        <Row>\n                            <h2>Local Match Viewer</h2>\n                        </Row>\n                        <Row>\n                            <h5>Choose a replay file that you want to view.</h5>\n                        </Row>\n                        <Row>\n                            <h5>If you want to run a file outside of a replays/ directory run <b>lia -r [path-to-replay]</b></h5>\n                        </Row>\n                        <Row>\n                            {(currentPath !== \"/\")\n                                ? <Row key={-1} className=\"replay-picker-item\">\n                                    {/* eslint-disable-next-line jsx-a11y/anchor-is-valid */}\n                                    <a onClick={this.back} className=\"replay-picker-item\">..</a>\n                            </Row>\n                                : null\n                            }\n                            {directoryItems.map((item: string, i: number) => {\n                                return <Row key={i}>\n                                    {/* eslint-disable-next-line jsx-a11y/anchor-is-valid */}\n                                    <a onClick={() => {this.navigate(this.state.currentPath, item)}}\n                                       className=\"replay-picker-item\">\n                                        <li>{item}</li>\n                                    </a>\n                                </Row>\n                            })}\n                        </Row>\n                    </Col>\n                </Row>\n            </Grid>\n        )\n    }\n}","import React from 'react';\nimport './_dependencies/components/matchViewer.css';\nimport './App.css';\nimport {BrowserRouter as Router, Route, Switch} from 'react-router-dom'\nimport {LocalMatchViewer} from \"./components/LocalMatchViewer\";\nimport {ReplayPicker} from \"./components/ReplayPicker\";\n\n\nconst App: React.FC = () => {\n    let assetsServerPort = process.env.REACT_APP_ASSETS_SERVER_PORT;\n\n    return (\n        <Router>\n            <Switch>\n                <Route exact path=\"/\" component={(props) =>\n                    <ReplayPicker assetsServerPort={assetsServerPort} {...props} />}\n                />\n                <Route exact path=\"/viewer\" component={(props) =>\n                    <LocalMatchViewer assetsServerPort={assetsServerPort} {...props} />}\n                />\n            </Switch>\n        </Router>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(\n            (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n            window.location.href\n        );\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                        'worker. To learn more, visit https://bit.ly/CRA-PWA'\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                'No internet connection found. App is running in offline mode.'\n            );\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}