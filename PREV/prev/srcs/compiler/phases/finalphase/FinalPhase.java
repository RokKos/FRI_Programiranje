/**
 * @author kos
 */
package compiler.phases.finalphase;

import java.io.IOException;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.File;
import java.util.Vector;

import compiler.Main;
import compiler.common.report.Report;
import compiler.data.asmcode.AsmInstr;
import compiler.data.asmcode.AsmLABEL;
import compiler.data.asmcode.AsmOPER;
import compiler.data.asmcode.Code;
import compiler.data.chunk.DataChunk;
import compiler.data.layout.Label;
import compiler.data.layout.Temp;
import compiler.phases.*;
import compiler.phases.asmcode.AsmGen;
import compiler.phases.chunks.Chunks;

public class FinalPhase extends Phase {

	private final String kJump = "JMP ";
	private final String kSetConstPrePendix = "SET $0,";
	private final String kINCLow = "INCML $0,";
	private final String kINCMidHigh = "INCMH $0,";
	private final String kINCHigh = "INCH $0,";
	private final String kFP = "FP";// "$253";
	private final String kSP = "SP";// "$254";

	public FinalPhase() {
		super("final");
	}

	private Vector<AsmInstr> SetConstant(long value) {
		Vector<AsmInstr> instructions = new Vector<>();
		int bits = ((short) value & 0xffff);
		instructions.add(new AsmOPER(kSetConstPrePendix + bits, null, null, null));
		value >>= 16;

		if (value > 0) {
			bits = ((short) value & 0xffff);
			instructions.add(new AsmOPER(kINCLow + bits, null, null, null));
			value >>= 16;
		}

		if (value > 0) {
			bits = ((short) value & 0xffff);
			instructions.add(new AsmOPER(kINCMidHigh + bits, null, null, null));
			value >>= 16;
		}

		if (value > 0) {
			bits = ((short) value & 0xffff);
			instructions.add(new AsmOPER(kINCHigh + bits, null, null, null));
			value >>= 16;
		}

		return instructions;
	}

	private boolean IsMain(Code code) {
		return code.frame.label.name.equals("_main");
	}

	private Vector<AsmInstr> CreateProlog(Code code) {
		Vector<AsmInstr> instr = new Vector<>();
		instr.add(new AsmOPER("% --- Prolog ---", null, null, null));
		instr.add(new AsmLABEL(code.frame.label));

		// Storing FP
		instr.addAll(SetConstant(code.frame.locsSize + 2 * 8));
		instr.add(new AsmOPER("% Storing FP ", null, null, null));
		instr.add(new AsmOPER("SUB $0," + kFP + ",$0", null, null, null));
		instr.add(new AsmOPER("STO " + kFP + ",$0,0", null, null, null));

		// STORING RA
		instr.add(new AsmOPER("% STORING RA ", null, null, null));
		instr.add(new AsmOPER("GET $1,rJ", null, null, null));
		instr.add(new AsmOPER("STO $1," + kFP + ",8", null, null, null));

		instr.add(new AsmOPER("% Lowering FP ", null, null, null));
		instr.add(new AsmOPER("SET " + kFP + "," + kSP, null, null, null));

		instr.add(new AsmOPER("% Lowering SP ", null, null, null));
		instr.addAll(SetConstant(code.frame.size + code.tempSize));
		instr.add(new AsmOPER("SUB " + kSP + "," + kSP + ",$0", null, null, null));

		Vector<Label> jumps = new Vector<>();
		jumps.add(code.entryLabel);
		instr.add(new AsmOPER(kJump + code.entryLabel.name, null, null, jumps));
		return instr;
	}

	private Vector<AsmInstr> CreateEpilogue(Code code) {
		Vector<AsmInstr> instr = new Vector<>();
		instr.add(new AsmOPER("% --- Epilogue ---", null, null, null));
		instr.add(new AsmLABEL(code.exitLabel));

		// Save return value
		instr.add(new AsmOPER("STO $0," + kFP + ",0  % Save return value ", null, null, null));

		// Highering Stack pointer
		instr.add(new AsmOPER("% Highering Stack pointer ", null, null, null));
		instr.addAll(SetConstant(code.frame.size + code.tempSize));
		instr.add(new AsmOPER("ADD " + kSP + "," + kSP + ",$0", null, null, null));

		instr.add(new AsmOPER("% Getting RA ", null, null, null));
		instr.addAll(SetConstant(code.frame.locsSize));
		instr.add(new AsmOPER("SUB $0," + kSP + ",$0", null, null, null));

		instr.add(new AsmOPER("LDO $1,$0,8", null, null, null));
		instr.add(new AsmOPER("PUT rJ,$1", null, null, null));

		instr.add(new AsmOPER("% Getting old FP ", null, null, null));
		instr.add(new AsmOPER("LDO " + kFP + ",$0,0", null, null, null));
		instr.add(new AsmOPER("POP 15,0", null, null, null));

		return instr;

	}

	public void Finish() {
		for (Code code : AsmGen.codes) {
			code.instrs.addAll(0, CreateProlog(code));
			code.instrs.addAll(CreateEpilogue(code));
		}

		Vector<String> bootstrapCode = new Vector<>();
		bootstrapCode.add("% Code generated by PREV compiler");

		bootstrapCode.add("SP\tGREG\tStack_Segment");
		bootstrapCode.add("FP\tGREG\tStack_Segment");

		bootstrapCode.add("\tLOC\tData_Segment");
		bootstrapCode.add("DATA\tGREG\t@");

		for (DataChunk data : Chunks.dataChunks) {
			bootstrapCode.add(data.label.name + "\t" + data.init + ",0");
		}

		bootstrapCode.add("% Code Segment");
		bootstrapCode.add("\tLOC\t#500");
		// bootstrapCode.add("\tGREG\t@");
		bootstrapCode.add("Main\tPUSHJ\t$15,main");

		bootstrapCode.add("% STOPPING PROGRAM");
		bootstrapCode.add("\tTRAP\t0,Halt,0");

		try {
			OutputStream os = new FileOutputStream(new File(Main.cmdLineArgValue("--dst-file-name")));

			for (String line : bootstrapCode) {
				os.write((line + "\n").getBytes());
			}

			for (Code code : AsmGen.codes) {
				os.write(("% Code for function: " + code.frame.label.name + "\n").getBytes());
				for (AsmInstr instr : code.instrs) {
					if (instr instanceof AsmLABEL) {
						os.write((instr.toAsemblerCode(code.regs)).getBytes());
					} else {
						os.write((instr.toAsemblerCode(code.regs) + "\n").getBytes());
					}
				}

			}

			os.close();
		} catch (IOException e) {
			throw new Report.Error(e.toString());
		}

	}

	public void log() {
		if (logger == null)
			return;
		for (Code code : AsmGen.codes) {
			logger.begElement("code");
			logger.addAttribute("entrylabel", code.entryLabel.name);
			logger.addAttribute("exitlabel", code.exitLabel.name);
			logger.addAttribute("tempsize", Long.toString(code.tempSize));
			code.frame.log(logger);
			logger.begElement("instructions");
			for (AsmInstr instr : code.instrs) {
				logger.begElement("instruction");
				logger.addAttribute("code", instr.toString(code.regs));
				logger.endElement();
			}
			logger.endElement();
			logger.endElement();
		}
	}

}
